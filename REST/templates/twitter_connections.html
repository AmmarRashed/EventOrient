<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

    <style>
    body {font-family: 'Times', cursive;}
    path {
        fill-opacity: .1;
        stroke-opacity: 1;
    }

</style>
<div class="ui-widget">
    <input id="search" size='54'>
    <button type="button" onclick="searchNode()">Find Node</button>
    <button type="button" onclick="resetNodes()">Reset</button>
    <br>

    <form name="myForm" method="POST">
        {% csrf_token %}

        <p id="textDate">Date: {{current_date}}</p>
        <input type="range" id="date_scroller" name="date" min="0" max="{{dates|length|add:"-1"}}" step="1" value="{{date_index}}"
                        style="width: 400px"
                onchange="updateDateText(this.value)">

        </br>
        Nodes: <span id="num_nodes">{{ nodes_number }}</span> </br> Edges: <span id="num_edges">{{ edges_number }}</span>
        <br>
        Homophily: {{ homophily_value }} ( Heterogeneity: {{ heterogeneity }}, Threshold: {{ heterogeneity_threshold }})
        <br>
        Transitivity: {{ transitivity_value }}
        <br>
        Recalculate node metrics:
        <input type="checkbox" id="recalculate_metrics" name="recalculate_metrics">
        <br>
        Recalculate communities:
        <input type="checkbox" id="recalculate_coms_checked" name="recalculate_coms_checked">
        <br>
        Recalculate SCCs:
        <input type="checkbox" id="recalculate_SCCs_checked" name="recalculate_SCCs_checked">
        <br>
        <input type="submit" value="Construct Network"></br>
        Include community accounts (e.g. clubs):
        <input type="checkbox" id="toggleFociCB" name="toggleFociCB" oninput="filterNodes()">
        <br>
        Friendship network (bidirectional edges only):
        <input type="checkbox" id="bidir" name="bidir"> There are {{ bidir_edges }} ({{ bidir_ratio }} %) bidirectional connections out of {{ edges_number }}
        <br>
        <br>
        degree: <input type="text" id="text_degree" value="{{degree_threshold}}" style="width: 50px"
                       name="text_degree"
                        onchange="updateScroll(this.value, 'degree')">{{avg_degree}}<br>

        0<input id="degree"
                type="range" value="{{degree_threshold}}" min="0" max="100" step="1"
                style="width: 400px"
                onchange="updateText(this.value, 'text_degree')">100
        <br>

        betweenness: <input type="text" id="text_betweenness" value="{{btw_threshold}}" style="width: 50px"
                            name="text_betweenness"
                        onchange="updateScroll(this.value, 'betweenness')">{{avg_betweenness}}<br>

        0.0<input id="betweenness"
                type="range" value="{{btw_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_betweenness')">1.0
        <br>
        pagerank: <input type="text" id="text_pagerank" value="{{pagerank_threshold}}" style="width: 50px"
                         name="text_pagerank"
                        onchange="updateScroll(this.value, 'pagerank')">{{avg_pagerank}}<br>

        0.0<input id="pagerank"
                type="range" value="{{pagerank_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_pagerank')">1.0
        <br>
        closeness: <input type="text" id="text_closeness_centrality" value="{{closeness_threshold}}" style="width: 50px"
                          name="text_closeness_centrality"
                        onchange="updateScroll(this.value, 'closeness_centrality')">{{avg_closeness_centrality}}<br>

        0.0<input id="closeness_centrality"
                type="range" value="{{closeness_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_closeness_centrality')">1.0
        <br>

        eigenvector: <input type="text" id="text_eigenvector_centrality" value="{{eigenvector_threshold}}" style="width: 50px"
                            name="text_eigenvector_centrality"
                        onchange="updateScroll(this.value, 'eigenvector_centrality')">{{avg_eigenvector_centrality}}<br>

        0.0<input id="eigenvector_centrality"
                type="range" value="{{eigenvector_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_eigenvector_centrality')">1.0

        <br>
        Clustering Coefficient: <input type="text" id="text_clustering_coefficient" value="{{clust_threshold}}" style="width: 50px"
                            name="text_clustering_coefficient"
                        onchange="updateScroll(this.value, 'clustering_coefficient')">{{avg_clustering_coefficient}}<br>

        0.0<input id="clustering_coefficient"
                type="range" value="{{clust_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_clustering_coefficient')">1.0

        <br>
        Nodes size by:
        <select id="sizeBy" onchange="updateSize()">

        {% for metric in size_metrics %}
            <option value="{{ metric }}">{{ metric }}</option>
        {% endfor %}
        </select>
        <br>
    </form>
    <input id="filter" type="submit" value="filter" onclick="drawNetwork()">
</div>

<div id="groupSettings">
    <p>Group by: <span id='groupLabel'>None</span></p>
</div>

{#<div id="curveSettings">#}
{#    <p>Type of curve: <span id='curveLabel'>curveBasisClosed</span></p>#}
{#</div>#}

<div id="scaleFactorSettings">
    <p>Scale of the groups: <span id='scaleFactorLabel'>1.2</span></p>
    <input type="range" min="1" max="3" value="1.2" step=".1" style="width: 400px"
           oninput="scaleFactor = value; d3.select('#scaleFactorLabel').text(scaleFactor); updateGroups()">

    <p>Network's gravity: <span id='gravityForce'>-600</span></p>
    <input type="range" min="-5000" max="200" value="-600" step="10" style="width: 400px"
           oninput="gravityForce = value; d3.select('#gravityForce').text(gravityForce); updateForce()">

    <p>Nodes' sizes: <span id='nodeScaler'>100</span></p>
    <input type="range" min="1" max="500" value="100" step="10" style="width: 400px"
           oninput="sizeScaler= value; d3.select('#nodeScaler').text(sizeScaler); resetNodes()">

</div>


<svg width="960" height="600"></svg>
<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">

<body>

<script>

    document.getElementById("recalculate_metrics").checked = {{recalculate_checked}};
    document.getElementById("recalculate_coms_checked").checked = {{recalculate_coms_checked}};
    document.getElementById("recalculate_SCCs_checked").checked = {{recalculate_SCCs_checked}};
    document.getElementById("toggleFociCB").checked = {{foci_checked}};

    document.getElementById("bidir").checked = {{bidir}};

    d3.select("svg").attr("width", window.screen.width)
        .attr("height", window.screen.height-150);

    // d3.select("svg").attr("width", 960)
    //     .attr("height", 500);

    const overhead = ["index","x","y","vy","vx"];

    var svg2 = d3.select("svg"),
        width = +svg2.attr("width"),
        height = +svg2.attr("height"),
        transform = d3.zoomIdentity;

    var svg = svg2.append("g");

    var zoom = d3.zoom()
        .scaleExtent([1 / 16, 8])
        .on("zoom", zoomed);

    svg2.call(zoom);

    zoom.scaleTo(svg2, 1/4);
    function zoomed() {
        svg.attr("transform", d3.event.transform);
    }
    svg.append('defs').append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':10,
            'markerHeight':10,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');


    var node,
        is_directed,
        valueline = d3.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .curve(d3.curveCatmullRomClosed),
        toggleFociChecked,
        selectedNodes,
        selectedLinks,
        paths,
        groups,
        groupIds,
        scaleFactor = 1.2,
        gravityForce = -600,
        sizeScaler=100,
        polygon,
        centroid,
        graph,
        color,
        size_metric, avgSize, maxSize, minSize,
        groupTypes = ["None","SCC", "community"],
        groupType = "None",
        simulation= d3.forceSimulation()
                            .force("link", d3.forceLink().id(function (d) {return d.id;}))
                            .force("charge", d3.forceManyBody().strength(gravityForce))
                            .force("center", d3.forceCenter(width/2, height/2));


    is_directed = true;  // TODO set checkbox for that

    {#var curveTypes = ['curveBasisClosed', 'curveCardinalClosed', 'curveCatmullRomClosed', 'curveLinearClosed'],#}

    {#selectedDegree = document.getElementById('degree').value;#}

    {#drawNetwork(selectedDegree, is_directed);#}
    drawNetwork();

    function drawNetwork(){
        d3.json("{% url 'Twitter:load_twitter_connections_json' %}", function(error, g) {
            if (error) throw error;

            graph = g;

            d3.selectAll('.select_group').remove();
            svg.selectAll('*').remove();

            if (typeof selectedNodes == 'undefined') {  // first run
                selectedNodes = graph.nodes;
                filterNodes();
            }

            d3.select('#groupSettings')
            .append('select')
            .attr('class','select_group')
            .on('change', function() {
                var val = d3.select('.select_group').property('value');
                d3.select('#groupLabel').text(val);
                groupType = val;
                {#valueline.curve(d3[val]);#}
                updateGroupIds();
                updateGroups();
            })
            .selectAll('option')
                .data(groupTypes).enter()
                .append('option')
                .text(function (d) { return d; });


            // create groups, links and nodes
            groups = svg.append('g').attr('class', 'groups');

            var colors = [];
            var i;
            for (i = 0; i < selectedNodes.length; i++) {
                colors.push(getRandomColor());
            }
            color = d3.scaleOrdinal(colors);

            var link = svg.append("g")
                .style("stroke", "#aaa")
                .style("stroke-opacity", "0.8")
                .selectAll("line")
                .data(selectedLinks)
                .enter().append("line")
                .attr('marker-end', 'url(#arrowhead)');


            node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(selectedNodes)
                .enter().append("circle")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));


            var label = svg.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(selectedNodes)
                .enter().append("text")
                .attr("class", "label");
            // .text(function(d){return d.id;});

            updateSize();

            svg.selectAll("circle")
                .on("mouseover", function (d) {

                    d3.select(this).style("r", node_over);

                    const focus = svg.append('g')
                        .attr('class', 'focus');
                    const cx = d3.select(this).attr("cx");
                    const cy = d3.select(this).attr("cy");

                    focus.append('rect')
                        .attr('height', 300 * 4)
                        .attr('width', 300 * 4)
                        .attr("x", cx)
                        .attr("y", cy);
                    var x = 0.0;
                    for (var metric in d) {
                        x += 1.2;
                        if (overhead.indexOf(metric) < 0) {
                            focus.append('text')
                                .attr('x', cx + 10)
                                .attr('y', cy + 10)
                                .attr('dy', x + 'em')
                                .attr('dx', '.5em')
                                .style("font-size", 50)
                                .text(metric + ": " + d[metric]);
                        }
                    }

                    d3.select('.overlay')
                        .styles({
                            fill: 'none',
                            'pointer-events': 'all'
                        });

                    d3.selectAll('.focus')
                        .style('opacity', 0.9);

                    d3.selectAll('.focus rect')
                        .styles({
                            fill: '#CFEEF1',
                            stroke: 'black'
                        });
                })
                .on("mouseout", function (d) {
                    d3.select(this).style("r", node_scale).style("fill-opacity", 0.7);
                    d3.selectAll(".focus").remove();
                });


            simulation
                .nodes(selectedNodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(selectedLinks);

            function ticked() {
                link
                    .attr('x1', d => d.source.x )
                    .attr('y1', d => d.source.y )
                    .attr('x2', d => d.target.x )
                    .attr('y2', d => d.target.y );

                node
                    .attr("r", node_scale)
                    .attr('cx', d => d.x )
                    .attr('cy', d => d.y )
                    .style('fill-opacity', 0.7)
                    .style('fill', d => color(d.community))
                    .style('stroke', "none");

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .style("font-size", "10px")
                    .style("fill", "#4393c3")
                    .text(d => d.screen_name);


                updateGroups();

            }

        });

    }
        // .domain([{{minSize}},{{maxSize}}])
        // .range([1, 50]);

        function node_scale(d){

                return Math.max((Math.abs(d[size_metric]- avgSize))/(maxSize-minSize)*sizeScaler, sizeScaler/20);
            }
    function node_over(d){

        return Math.max((Math.abs(d[size_metric] - avgSize))/(maxSize-minSize)* (sizeScaler*1.8), sizeScaler*2);

    }

    function dragstarted(d){
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d){
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d){
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }


    // drag groups
    function group_dragstarted(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 3);
    }

    function group_dragged(groupId) {
        node
            .filter(function(d) { return d[groupType] == groupId; })
            {#.filter(function(d) { return d['SCC'] == groupId; })#}
            .each(function(d) {
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            })
    }

    function group_dragended(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 1);
    }


    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    function searchNode() {
        var selectedVal = document.getElementById('search').value;
        if (selectedVal == 'none') {}
        else {
            var selected = node.filter(function (d, i) {
                return (d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });

            var nonselected = node.filter(function (d, i) {
                return !(d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });
            nonselected.style("opacity", "0.1");
            selected.style("opacity", 1.0);
            selected.style("r",node_over);
            alert("Found: "+selected.size().toString());
            centerNode(selected.attr("cx"), selected.attr("cy"));

            // var link = svg.selectAll(".link");
            // link.style("opacity", "0");
            d3.selectAll(".node, .link").transition()
                .duration(3000)
                .style("opacity", '1');
        }

    }
    function resetNodes(){
        var all_nodes = node.filter(function (d, i){
            return true;
        });
        all_nodes.style("r", node_scale)
            .style("opacity",0.7);
    }
    function updateText(threshold, widget){
        {#var metric = widget.slice(5);  // text_degree => degree  (removing 'text_')#}

        document.getElementById(widget).value=threshold;
        filterNodes();
    }
    function updateScroll(threshold, widget){

        document.getElementById(widget).value=threshold;
        filterNodes();
    }

    function centerNode(xx, yy){
        svg.transition()
        .duration(500)
        .attr("transform", "translate(" + (width/2 - xx) + "," + (height/2 - yy) + ")scale(" + 1 + ")")
        .on("end", function(){ svg2.call(zoom.transform, d3.zoomIdentity.translate((width/2 - xx),(height/2 - yy)).scale(1))});
        }

    function updateDateText(date_index){
        var dates = {{dates_dumped|safe}};
        document.getElementById("textDate").innerHTML = "Date: "+dates[date_index].toString();
    }


    // select nodes of the group, retrieve its positions
    // and return the convex hull of the specified points
    // (3 points as minimum, otherwise returns null)
    var polygonGenerator = function(groupId) {
        var node_coords = node
            .filter(function(d) { return d[groupType] == groupId; })
            .data()
            .map(function(d) { return [d.x, d.y]; });

        return d3.polygonHull(node_coords);
    };


    function updateForce(){
        simulation.force("charge", d3.forceManyBody().strength(gravityForce));
        ticked();

    }

    function updateSize(){
                size_metric = document.getElementById("sizeBy").value;
                avgSize = 0;
                maxSize = 0;
                minSize = Infinity;

                selectedNodes.forEach(function (d) {
                    avgSize += d[size_metric];
                    maxSize = Math.max(maxSize, d[size_metric]);
                    minSize = Math.min(maxSize, d[size_metric]);
                });
                avgSize /= selectedNodes.length;

                resetNodes();
            }

    function updateGroups() {
        if (typeof groupIds != 'undefined') {

            groupIds.forEach(function (groupId) {
                var path = paths.filter(function (d) {
                    return d == groupId;
                })
                    .attr('transform', 'scale(1) translate(0,0)')
                    .attr('d', function (d) {
                        polygon = polygonGenerator(d);
                        centroid = d3.polygonCentroid(polygon);

                        // to scale the shape properly around its points:
                        // move the 'g' element to the centroid point, translate
                        // all the path around the center of the 'g' and then
                        // we can scale the 'g' element properly
                        return valueline(
                            polygon.map(function (point) {
                                return [point[0] - centroid[0], point[1] - centroid[1]];
                            })
                        );
                    });

                d3.select(path.node().parentNode).attr('transform', 'translate(' + centroid[0] + ',' + (centroid[1]) + ') scale(' + scaleFactor + ')');
            });
        }
    }

    function updateLinks(){
        graph.links.forEach(function (d) {
            d.source = d.source;
            d.target = d.target;
        });
        selectedLinks = graph.links.filter(function(l){
            var valid=0;
            for (var n in selectedNodes){
                node_id = parseInt(selectedNodes[n].id);
                source_id = parseInt(l.source);
                target_id = parseInt(l.target);

                {#console.log(node_id, source_id, l.source);#}

                if (node_id === source_id)
                    valid += 1;
                if (node_id === target_id)
                    valid += 1;
                if (valid>1)
                    return true;
            }
            return false;
            {#return selectedNodes.includes(link.source) && selectedNodes.includes(link.target);#}
        });
        d3.select("#num_nodes").text(selectedNodes.length.toString());
        d3.select("#num_edges").text(selectedLinks.length.toString());

        drawNetwork();
    }

    function filterNodes() {
        var metrics = ["degree", "betweenness", "pagerank", "community",
                "closeness_centrality", "eigenvector_centrality", 'clustering_coefficient'];

        toggleFociChecked = document.getElementById("toggleFociCB").checked;

        selectedNodes =
            graph.nodes.filter(function(node){
                for (var metric in node) {
                    if (metrics.includes(metric)) {
                        if (metric.includes("community")) {
                            if (!(toggleFociChecked || !(node['community'].toString().includes("foci"))))
                                return false;
                        }
                        else {
                            var metricThreshold = parseFloat(document.getElementById(metric).value);
                            if (node[metric] < metricThreshold)
                                return false;
                        }
                    }
                }
                return true;
            });
        updateLinks();
    }


    function updateGroupIds(){
            // count members of each group. Groups with less
            // than 3 member will not be considered (creating
            // a convex hull need 3 points at least)

            groups.selectAll('.path_placeholder').remove();

            groupIds = d3.set(selectedNodes.map(function(n) { return +n[groupType]; }))
                .values()
                .map( function(groupId) {
                    return {
                        groupId : groupId,
                        count : selectedNodes.filter(function(n) { return +n[groupType]  == groupId; }).length

                    };
                })
                .filter( function(group) { return group.count > 2;})
                .map( function(group) { return group.groupId; });

            paths = groups.selectAll('.path_placeholder')
                .data(groupIds, function(d) { return +d; })
                .enter()
                .append('g')
                .attr('class', 'path_placeholder')
                .append('path')
                .attr('stroke', function(d) { return color(d); })
                .attr('fill', function(d) { return color(d); })
                .attr('opacity', 0);

            paths
                .transition()
                .duration(1000)
                .attr('opacity', 1);

            // add interaction to the groups
            groups.selectAll('.path_placeholder')
                .call(d3.drag()
                    .on('start', group_dragstarted)
                    .on('drag', group_dragged)
                    .on('end', group_dragended)
                )
                .on("click", function(){console.log(d3.select(this).data());})

            }


</script>



</body>
