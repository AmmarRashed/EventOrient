<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

<style>
    body {
        font-family: 'Times', cursive;
    }

.hoverP{
    white-space: normal;
    width: 300px;
    }

    path {
        fill-opacity: .2;
        stroke-opacity: 1;
        stroke-width: 2;
    }

    .column {
        float: left;
        padding: 5px;
    }

    .row::after {
        content: "";
        clear: both;
        display: table;
    }

</style>
<body>
    <input id="search" size='25'>
    <button type="button" onclick="searchNode()">Find Node</button>
    <button type="button" onclick="resetNodes()">Reset</button>

<div class="row">
<div id="groupSettings" class="column">
        Group by: <span id='groupLabel'></span>
    </div>
<div class="column">
    Nodes size by:
            <select id="sizeBy" onchange="updateSize()">

                {% for metric in size_metrics %}
                    <option value="{{ metric }}">{{ metric }}</option>
                {% endfor %}
            </select>
</div>

        Node scale: <span id='nodeScaler'>100</span>
    <input type="range" min="1" max="500" value="100" step="10" style="width: 150px"
           oninput="sizeScaler= value; d3.select('#nodeScaler').text(sizeScaler); resetNodes()">

    Edge width: <span id='edgeScaler'>1.0</span>
    <input type="range" min="0.1" max="10" value="1.0" step="0.1" style="width: 200px"
           oninput="esizeScaler= value; d3.select('#edgeScaler').text(esizeScaler); resetEdges()">

    Scale of the groups: <span id='scaleFactorLabel'>1.2</span>
    <input type="range" min="1" max="3" value="1.2" step=".1" style="width: 200px"
           oninput="scaleFactor = value; d3.select('#scaleFactorLabel').text(scaleFactor); updateGroupPolygons()">

    Network's gravity: <span id='gravityForce'>-600</span>
    <input type="range" min="-5000" max="200" value="-600" step="10" style="width: 200px"
           oninput="gravityForce = value; d3.select('#gravityForce').text(gravityForce); updateForce()">
</div>
<div class="row" width="100%">
    <div class="column" width="15.0%">
        <form name="myForm" method="POST">
            {% csrf_token %}

            <p id="textDate">Date: {{ current_date }}</p>
            <input type="range" id="date_scroller" name="date" min="0" max="{{ dates|length|add:"-1" }}" step="1"
                   value="{{ date_index }}"
                   style="width: 200px"
                   onchange="updateDateText(this.value)">

            </br>
        <p>
            Nodes: <span id="num_nodes">{{ nodes_number }}</span> </br> Edges: <span
                id="num_edges">{{ edges_number }}</span>
            <br>Communities: <span id="num_communities"></span></br>
            Homophily: {{ homophily_value }} <br>( Heterogeneity: {{ heterogeneity }},
            Threshold: {{ heterogeneity_threshold }})
            <br>
            Transitivity: {{ transitivity_value }}
            <br>
        </p>
        <div id="parameters">
            <p>
            Recalculate node metrics:
            <input type="checkbox" id="recalculate_metrics" name="recalculate_metrics">
            <br>
            Recalculate communities:
            <input type="checkbox" id="recalculate_coms_checked" name="recalculate_coms_checked">
            <br>
            Recalculate SCCs:
            <input type="checkbox" id="recalculate_SCCs_checked" name="recalculate_SCCs_checked">
            <br>
            Include community accounts (e.g. clubs):
            <input type="checkbox" id="toggleFociCB" name="toggleFociCB" oninput="updateLinks(); drawNetwork();">
            <br>
            Friendship (bidirectionals only):
            <input type="checkbox" id="toggleBidir" name="toggleBidir"
                   oninput="updateLinks(); drawNetwork();"> {{ bidir_edges }}/{{ edges_number }} ({{ bidir_ratio }}
            %)
            <br>
            <input type="submit" value="Construct Network"><br>
            </p>
        </div>
            degree: <input type="text" id="text_degree" value="0" style="width: 50px"
                           name="text_degree"
                           onchange="updateScroll(this.value, 'degree')">{{ avg_degree }}<br>

            0<input id="degree"
                    type="range" value="0" min="0" max="100" step="1"
                    style="width: 200px"
                    onchange="updateText(this.value, 'text_degree')">100
            <br>

            betweenness: <input type="text" id="text_betweenness" value="0" style="width: 50px"
                                name="text_betweenness"
                                onchange="updateScroll(this.value, 'betweenness')">{{ avg_betweenness }}<br>

            0.0<input id="betweenness"
                      type="range" value="0" min="0.0" max="1.0" step="0.01"
                      style="width: 200px"
                      onchange="updateText(this.value, 'text_betweenness')">1.0
            <br>
            pagerank: <input type="text" id="text_pagerank" value="0" style="width: 50px"
                             name="text_pagerank"
                             onchange="updateScroll(this.value, 'pagerank')">{{ avg_pagerank }}<br>

            0.0<input id="pagerank"
                      type="range" value="0" min="0.0" max="1.0" step="0.01"
                      style="width: 200px"
                      onchange="updateText(this.value, 'text_pagerank')">1.0
            <br>
            closeness: <input type="text" id="text_closeness_centrality" value="0" style="width: 50px"
                              name="text_closeness_centrality"
                              onchange="updateScroll(this.value, 'closeness_centrality')">{{ avg_closeness_centrality }}<br>

            0.0<input id="closeness_centrality"
                      type="range" value="0" min="0.0" max="1.0" step="0.01"
                      style="width: 200px"
                      onchange="updateText(this.value, 'text_closeness_centrality')">1.0
            <br>

            eigenvector: <input type="text" id="text_eigenvector_centrality" value="0" style="width: 50px"
                                name="text_eigenvector_centrality"
                                onchange="updateScroll(this.value, 'eigenvector_centrality')">{{ avg_eigenvector_centrality }}<br>

            0.0<input id="eigenvector_centrality"
                      type="range" value="0" min="0.0" max="1.0" step="0.01"
                      style="width: 200px"
                      onchange="updateText(this.value, 'text_eigenvector_centrality')">1.0

            <br>
            Clustering Coefficient: <input type="text" id="text_clustering_coefficient" value="0"
                                           style="width: 50px"
                                           name="text_clustering_coefficient"
                                           onchange="updateScroll(this.value, 'clustering_coefficient')">{{ avg_clustering_coefficient }}<br>

            0.0<input id="clustering_coefficient"
                      type="range" value="0" min="0.0" max="1.0" step="0.01"
                      style="width: 200px"
                      onchange="updateText(this.value, 'text_clustering_coefficient')">1.0

            <br>
        </form>
        <p>Include connection-less nodes
            <input id="edgeLess" type="checkbox" title="include nodes with no connections"
                   onchange="updateLinks(); drawNetwork();" checked></p>
        <p>Highlight edges on mouse-over
            <input id="edgeInfo" type="checkbox" title="Show edge info when you hover over it"
                   onchange="edgeInfo=this.checked; toggleEdgeInfo();" checked></p>
        {#<input id="filter" type="submit" title="remove nodes with no connections" value="Clean Network" onclick="filterEdgelessNodes();">#}

        {#<input id="bundleReset" type="submit" title="Ungroup all groups" value="Clear grouping" onclick="resetBundling();">#}
        {#<div id="curveSettings">#}
        {#    <p>Type of curve: <span id='curveLabel'>curveBasisClosed</span></p>#}
        {#</div>#}

    </div>

    <svg height="600" class="column" width="70.0%"></svg>
    <link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">

    <div id="hoverInfo" class="column" width="15.0%">
    </div>
</div>
    <div id="distInfo"></div>

<script>

    document.getElementById("recalculate_metrics").checked = {{recalculate_checked}};
    document.getElementById("recalculate_coms_checked").checked = {{recalculate_coms_checked}};
    document.getElementById("recalculate_SCCs_checked").checked = {{recalculate_SCCs_checked}};
    document.getElementById("toggleFociCB").checked = {{foci_checked}};

    document.getElementById("toggleBidir").checked = {{bidir}};

    d3.select("svg").attr("width", window.screen.height)
        .attr("height", window.screen.height - 200);

    // d3.select("svg").attr("width", 960)
    //     .attr("height", 500);

    const overhead = ["index", "x", "y", "vy", "vx"];

    var svg2 = d3.select("svg"),
        width = +svg2.attr("width"),
        height = +svg2.attr("height"),
        transform = d3.zoomIdentity;

    var svg = svg2.append("g");

    var zoom = d3.zoom()
        .scaleExtent([1 / 16, 8])
        .on("zoom", zoomed);

    svg2.call(zoom);

    zoom.scaleTo(svg2, 1 / 4);

    function zoomed() {
        svg.attr("transform", d3.event.transform);
    }

    var node,
        link,
        label,
        is_directed,
        communitiesSet,
        valueline = d3.line()
            .x(function (d) {
                return d[0];
            })
            .y(function (d) {
                return d[1];
            })
            .curve(d3.curveCatmullRomClosed),
        collapseMap,
        edgeInfo,
        toggleFociChecked,
        groupMap,
        nodesIndices,
        selectedNodes,
        selectedLinks,
        paths,
        groups,
        groupIds,
        scaleFactor = 1.2,
        gravityForce = -600,
        sizeScaler = 100,
        esizeScaler = 1,
        polygon,
        centroid,
        graph,
        color = d3.scaleOrdinal({{ colors|safe }}),
        size_metric, avgSize, maxSize, minSize,
        groupTypes = ["None", "SCC", "community"],
        groupType = "None",
        simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function (d) {
                return d.id;
            }))
            .force("charge", d3.forceManyBody().strength(gravityForce))
            .force("center", d3.forceCenter(width / 2, height / 2));

    is_directed = true;  // TODO set checkbox for that
    //color = d3.scaleOrdinal(d3.schemeCategory20);
    {#var curveTypes = ['curveBasisClosed', 'curveCardinalClosed', 'curveCatmullRomClosed', 'curveLinearClosed'],#}

    {#selectedDegree = document.getElementById('degree').value;#}

    {#drawNetwork(selectedDegree, is_directed);#}
    initNetwork();

    var fr = {};

    function initNetwork() {
        d3.json("{% url 'Twitter:load_twitter_connections_json' %}", function (error, g) {
            if (error) throw error;

            graph = g;
            simulation.alphaTarget(0.0).restart();
            d3.selectAll('.select_group').remove();

            if (selectedNodes === undefined) {  // first run
                selectedNodes = JSON.parse(JSON.stringify(graph.nodes));
                updateGraphLinks();
                updateLinks();
            }

            d3.select('#groupSettings')
                .append('select')
                .attr('class', 'select_group')
                .on('change', function () {
                    var val = d3.select('.select_group').property('value');

                    groupType = val;
                    {#valueline.curve(d3[val]);#}
                    if (fr[groupType] === undefined) {
                        updateGroupIds();
                        fr[groupType] = {"ids": groupIds, "groupMap": groupMap};
                        var i = 0;
                        groupIds.forEach(function (d) {
                            i += 1;
                        });
                        console.log(groupType, i)
                    } else {
                        console.log("LOADING:", groupType, "Stats");
                        groupIds = fr[groupType]["ids"];
                        groupMap = fr[groupType]["groupMap"];
                    }
                    updatePaths();
                    updateGroupPolygons();
                })
                .selectAll('option')
                .data(groupTypes).enter()
                .append('option')
                .text(function (d) {
                    return d;
                });


            // create groups, links and nodes
            groups = svg.append('g').attr('class', 'groups');

            /*communitiesSet.forEach(function (c){
               colors.push(getRandomColor());
            });*/

            /*if (communitiesSet.size > colors.length) {
                for (var i = 0; i < Math.max(communitiesSet.size, 50); i++)  // add more 50 colors
                    colors.push(getRandomColor());
            }

            color = d3.scaleOrdinal(colors);*/
            drawNetwork();
        });

    }

    function toggleEdgeInfo() {
        if (edgeInfo) {
            svg.selectAll("line")
                .on("mouseover", function (d) {
                    d3.select(this).style("stroke-width", link_over);
                    const focus = svg.append('g')
                        .attr('class', 'focus');
                    const cx = svg2.mouse(this)[0];
                    const cy = svg2.mouse(this)[1];
                    focus.append('rect')
                        .attr('height', 180)
                        .attr('width', 300)
                        .style("stroke-width", "0.05")
                        .attr("x", cx)
                        .attr("y", cy);
                    var x = 0.0;
                    for (var metric in d) {
                        var s;
                        if (metric == "weight") {
                            s = d[metric];
                        }
                        else {
                            s = d[metric].name;
                        }
                        if (overhead.indexOf(metric) < 0) {
                            x += 1.2;
                            focus.append('text')
                                .attr('x', cx)
                                .attr('y', cy)
                                .attr('dy', x + 'em')
                                .attr('dx', '.5em')
                                .style("font-size", 30)
                                .text(metric + ": " + s);
                        }
                    }
                    d3.select('.overlay')
                        .styles({
                            fill: 'none',
                            'pointer-events': 'all'
                        });
                    d3.selectAll('.focus')
                        .style('opacity', 0.9);
                    d3.selectAll('.focus rect')
                        .styles({
                            fill: '#CFEEF1',
                            stroke: 'black'
                        });
                })
                .on("mouseout", function (d) {
                    d3.select(this).style("stroke-width", link_weight);
                    d3.selectAll(".focus").remove();
                });
        }
        else {

            svg.selectAll("line").on("mouseover", null);
        }
    }

    function drawNetwork() {
        svg.selectAll(".links").remove();
        svg.selectAll(".nodes").remove();
        svg.selectAll(".labels").remove();
        if (groupType != 'None'){
            updatePaths();
            updateGroupPolygons();
        }
        svg.append('defs').append('marker')
        .attrs({
            'id': 'arrowhead',
            'viewBox': '-0 -5 10 10',
            'refX': 13,
            'refY': 0,
            'orient': 'auto',
            'markerWidth': 10,
            'markerHeight': 10,
            'xoverflow': 'visible'
        })
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke', 'none');



        link = svg.append("g")
            .style("stroke", "#aaa")
            .style("stroke-opacity", "0.8")
            .attr("class", "links")
            .selectAll("line")
            .data(selectedLinks)
            .enter().append("line")
            .attr('marker-end', 'url(#arrowhead)');


        node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(selectedNodes)
            .enter().append("circle")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(selectedNodes)
            .enter().append("text")
            .attr("class", "label");
        // .text(function(d){return d.id;});


        updateStatus();
        updateSize();

        svg.selectAll("circle")
            .on("mouseover", function (d) {

                d3.select(this).style("r", node_over);
                d3.select(this).style("fill-opacity", 0.9).style('stroke-width', 3);

                const focus = svg.append('g')
                    .attr('class', 'focus');
                const cx = d3.select(this).attr("cx");
                const cy = d3.select(this).attr("cy");

                focus.append('rect')
                    .attr('height', 520)
                    .attr('width', 850)
                    .attr("x", cx)
                    .attr("y", cy);
                var x = 0.0;
                var displayMetrics;
                var toGroupOver = false;
                if (groupMap === undefined || groupMap[d.id] === undefined){
                    displayMetrics = ["screen_name", "lang", "followers_count", "degree", "community"];
                }else{
                    console.log(d);
                    displayMetrics = ["name","community","size"];
                    toGroupOver = true;
                }
                displayMetrics.forEach(function (metric){

                    if (overhead.indexOf(metric) < 0) {
                        x += 1.2;
                        var val = isNaN(d[metric]) ? d[metric] :
                    (metric.includes("degree") || metric.includes("count") || groupTypes.includes(metric)) ? parseInt(d[metric]) :
                        parseFloat(d[metric]).toFixed(4);
                        focus.append('text')
                            .attr('x', cx + 10)
                            .attr('y', cy + 10)
                            .attr('dy', x + 'em')
                            .attr('dx', '.5em')
                            .style("font-size", 70)
                            .text(metric + ": " + val);
                    }
                });

                d3.select('.overlay')
                    .styles({
                        fill: 'none',
                        'pointer-events': 'all'
                    });

                d3.selectAll('.focus')
                    .style('opacity', 0.9);

                d3.selectAll('.focus rect')
                    .styles({
                        fill: '#CFEEF1',
                        stroke: 'black'
                    });
                if (toGroupOver)
                    groupOver(groupMap[d.id]);
            })
            .on("mouseout", function (d) {
                d3.select(this).style("r", node_scale).style("fill-opacity", 0.7).style('stroke-width', 2);
                d3.selectAll(".focus").remove();
            })
            .on("click", function (d) {
                if (groupMap === undefined) {
                    groupOver(d);
                }
                else if (groupMap[d] === undefined) {
                    if (groupMap[d.id] === undefined) {
                        groupOver(d);
                    }
                    else {
                        bundleNodes(d.id);
                    }
                }
                else {
                    bundleNodes(d);
                }
            });

        svg.selectAll("line")
            .on("mouseover", function (d) {
                d3.select(this).style("stroke-width", link_over);
                const focus = svg.append('g')
                    .attr('class', 'focus');
                const cx = d3.mouse(this)[0];
                const cy = d3.mouse(this)[1];
                focus.append('rect')
                    .attr('height', 180)
                    .attr('width', 300)
                    .style("stroke-width", "0.05")
                    .attr("x", cx)
                    .attr("y", cy);
                var x = 0.0;
                for (var metric in d) {
                    var s;
                    if (metric == "weight") {
                        s = d[metric];
                    }
                    else {
                        s = d[metric].name;
                    }
                    if (overhead.indexOf(metric) < 0) {
                        x += 1.2;
                        focus.append('text')
                            .attr('x', cx)
                            .attr('y', cy)
                            .attr('dy', x + 'em')
                            .attr('dx', '.5em')
                            .style("font-size", 30)
                            .text(metric + ": " + s);
                    }
                }
                d3.select('.overlay')
                    .styles({
                        fill: 'none',
                        'pointer-events': 'all'
                    });
                d3.selectAll('.focus')
                    .style('opacity', 0.9);
                d3.selectAll('.focus rect')
                    .styles({
                        fill: '#CFEEF1',
                        stroke: 'black'
                    });
            })
            .on("mouseout", function (d) {
                d3.select(this).style("stroke-width", link_weight);
                d3.selectAll(".focus").remove();
            });

        simulation
            .nodes(selectedNodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(selectedLinks);

        function ticked() {

            link
                .attr('x1', d => d.source.x
        )
        .
            attr('y1', d => d.source.y
        )
        .
            attr('x2', d => d.target.x
        )
        .
            attr('y2', d => d.target.y
        )
            ;

            node
                .attr("r", node_scale)
                .attr('cx', d => d.x
        )
        .
            attr('cy', d => d.y
        )
        .
            style('fill-opacity', 0.7)
                .style('fill', d => color(d.community)
        )
        .
            style('stroke', "none");

            label
                .attr("x", d => d.x
        )
        .
            attr("y", d => d.y
        )
        .
            style("font-size", "10px")
                .style("fill", "#4393c3")
                .text(function(d){return (groupMap === undefined || groupMap[d.id] === undefined)?
                    d.screen_name:d.name;})
            ;

            updateGroupPolygons();
        }
    }

    /*function restartNetwork(_nodes, _links){

        if (_nodes === undefined)
            _nodes = JSON.parse(JSON.stringify(selectedNodes));

        if (_links === undefined)
            _links = JSON.parse(JSON.stringify(selectedLinks));

        node = node.data(_nodes);
        node.exit().remove();

        link = link.data(_links);
        link.exit().remove();

        label = label.data(_nodes);
        label.exit().remove();

        simulation.nodes(_nodes);
        simulation.force("link")
            .links(_links);

    }*/


    // .domain([{{minSize}},{{maxSize}}])
    // .range([1, 50]);
    function node_scale(d) {
        return Math.max((Math.abs(d[size_metric] - avgSize)) / (maxSize - minSize) * sizeScaler, sizeScaler / 20);
    }

    function node_over(d) {
        return Math.max((Math.abs(d[size_metric] - avgSize)) / (maxSize - minSize) * (sizeScaler * 1.8), sizeScaler * 2);
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }


    // drag groups
    function group_dragstarted(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 3);
    }

    function group_dragged(groupId) {
        node
            .filter(function (d) {
                return d[groupType] == groupId;
            })
            {#.filter(function(d) { return d['SCC'] == groupId; })#}
            .each(function (d) {
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            })
    }

    function group_dragended(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0).restart();
        d3.select(this).select('path').style('stroke-width', 1);
    }

    /*var seed = 120;

    function random() {
        var x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    }


    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            //color += letters[Math.floor(Math.random() * 16)];
            color += letters[Math.floor(random() * 16)];
        }
        return color;
    }*/

    function link_weight(d) {
        if (d.weight === undefined) {
            d.weight = 1.0;
        }
        return Math.max(d.weight * esizeScaler, 1.0).toString();
    }

    function link_over(d) {
        if (d.weight === undefined) {
            d.weight = 1.0;
        }
        return Math.max(d.weight * esizeScaler, 1.0) * 5.0.toString();
    }

    function searchNode() {
        var selectedVal = document.getElementById('search').value;
        if (selectedVal == 'none') {
        }
        else {
            var selected = node.filter(function (d, i) {
                return (d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });

            var nonselected = node.filter(function (d, i) {
                return !(d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });
            nonselected.style("opacity", "0.1");
            selected.style("opacity", 1.0);
            selected.style("r", node_over);
            alert("Found: " + selected.size().toString());
            centerNode(selected.attr("cx"), selected.attr("cy"));

            // var link = svg.selectAll(".link");
            // link.style("opacity", "0");
            d3.selectAll(".node, .link").transition()
                .duration(3000)
                .style("opacity", '1');
        }

    }


    /*
    function resetBundling() {
        filterNodes();
        updateGraphLinks();
        filterBidirEdges();
        drawNetwork();
    }*/

    function resetEdges() {
        var all_edges = link.filter(function (d, i) {
            return true;
        });
        all_edges.style("stroke-width", link_weight);
    }

    function resetNodes() {
        var all_nodes = node.filter(function (d, i) {
            return true;
        });

        all_nodes.style("r", node_scale)
            .style("opacity", 0.7);
    }

    function updateText(threshold, widget) {
        {#var metric = widget.slice(5);  // text_degree => degree  (removing 'text_')#}

        document.getElementById(widget).value = threshold;
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }

    function updateScroll(threshold, widget) {

        document.getElementById(widget).value = threshold;
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }

    function centerNode(xx, yy) {
        svg.transition()
            .duration(500)
            .attr("transform", "translate(" + (width / 2 - xx) + "," + (height / 2 - yy) + ")scale(" + 1 + ")")
            .on("end", function () {
                svg2.call(zoom.transform, d3.zoomIdentity.translate((width / 2 - xx), (height / 2 - yy)).scale(1))
            });
    }

    function updateDateText(date_index) {
        var dates = {{dates_dumped|safe}};
        document.getElementById("textDate").innerHTML = "Date: " + dates[date_index].toString();
    }


    // select nodes of the group, retrieve its positions
    // and return the convex hull of the specified points
    // (3 points as minimum, otherwise returns null)
    var polygonGenerator = function (groupId) {
        var node_coords = node
            .filter(function (d) {
                return d[groupType] == groupId;
            })
            .data()
            .map(function (d) {
                return [d.x, d.y];
            });

        return d3.polygonHull(node_coords);
    };


    function updateForce() {
        simulation.force("charge", d3.forceManyBody().strength(gravityForce));

    }

    function updateSize() {
        size_metric = document.getElementById("sizeBy").value;
        avgSize = 0;
        maxSize = Number.NEGATIVE_INFINITY;
        minSize = Number.POSITIVE_INFINITY;

        selectedNodes.forEach(function (d) {
            avgSize += d[size_metric];
            maxSize = Math.max(maxSize, d[size_metric]);
            minSize = Math.min(maxSize, d[size_metric]);
        });
        avgSize /= selectedNodes.length;

        resetNodes();
    }

    function updateGroupPolygons() {
        if (!((groupIds === undefined) || (groupIds == null))) {
            try {
                groupIds.forEach(function (groupId) {
                    if (collapseMap[groupId]) {
                        var path = paths.filter(function (d) {
                            return collapseMap[d] ? d == groupId : false;
                            // return d == groupId;
                        });
                        path.attr('transform', 'scale(1) translate(0,0)')
                            .attr('d', function (d) {
                                polygon = polygonGenerator(d);
                                centroid = d3.polygonCentroid(polygon);

                                // to scale the shape properly around its points:
                                // move the 'g' element to the centroid point, translate
                                // all the path around the center of the 'g' and then
                                // we can scale the 'g' element properly
                                return valueline(
                                    polygon.map(function (point) {
                                        return [point[0] - centroid[0], point[1] - centroid[1]];
                                    })
                                );
                            });


                        d3.select(path.node().parentNode).attr('transform', 'translate(' + centroid[0] + ',' + (centroid[1]) + ') scale(' + scaleFactor + ')');
                    }
                });
            } catch (err) {
                console.log("ERROR:", err);
            }
        }
    }

    function countCommunities() {
        communitiesSet = new Set([]);
        selectedNodes.forEach(function (node) {
            communitiesSet.add(parseInt(node.community));
        });
        return communitiesSet.size;

    }

    function getLinkEnd(n) {
        if (typeof n == 'number')
            return n;
        else
            return parseInt(n.id);
    }

    function updateLinks() {
        filterNodes();
        selectedLinks = graph.links.filter(function (l) {
            var valid = 0;  // check if both ends of the connection are in selectedNodes

            for (var n in selectedNodes) {
                var node_id = getLinkEnd(selectedNodes[n]);
                var source_id = getLinkEnd(l.source);
                var target_id = getLinkEnd(l.target);


                {#console.log(node_id, source_id, l.source);#}

                if (node_id === source_id)
                    valid += 1;
                if (node_id === target_id)
                    valid += 1;
                if (valid > 1)
                    return true;
            }
            return false;
            {#return selectedNodes.includes(link.source) && selectedNodes.includes(link.target);#}
        });

        filterBidirEdges();
        filterEdgelessNodes();

        updateStatus();
    }

    function updateGraphLinks() {

        graph.links.forEach(function (d) {
            d.source = d.source;
            d.target = d.target;
        });

        selectedLinks = JSON.parse(JSON.stringify(graph.links));
    }

    function filterBidirEdges() {
        if (document.getElementById("toggleBidir").checked) {
            selectedLinks = selectedLinks.filter(function (l1) {
                for (var l2_ in selectedLinks) {
                    var l2 = selectedLinks[l2_];
                    {#console.log(l1.source, l2.source);#}
                    if ((getLinkEnd(l1.source) == getLinkEnd(l2.target)) && (getLinkEnd(l2.source) == getLinkEnd(l1.target)))
                        return true;
                }
                return false;
            });
        }
    }


    function updateStatus() {
        var comCount = countCommunities();

        d3.select("#num_nodes").text(selectedNodes.length.toString());
        d3.select("#num_edges").text(selectedLinks.length.toString());
        d3.select("#num_communities").text(comCount.toString());
    }


    function filterEdgelessNodes() {
        if (!document.getElementById("edgeLess").checked) {
            selectedNodes = selectedNodes.filter(function (n) {
                for (var l_ in selectedLinks) {
                    var l = selectedLinks[l_];
                    if ((getLinkEnd(l.source) == n.id) || (getLinkEnd(l.target) == n.id))
                        return true;
                }
                return false;
            });
        }
    }


    /*function toggleEdgeLessNodes(){
        var edgeLessCB = document.getElementById("edgeLess").checked;
        var edgedNodes;
        if (!edgeLessCB) {
            edgedNodes = selectedNodes.filter(function (n) {
                for (var l_ in selectedLinks) {
                    var l = selectedLinks[l_];
                    if ((getLinkEnd(l.source) == n.id) || (getLinkEnd(l.target) == n.id)) {
                        return true;
                    }
                }
                return false;
            });
        }else{
            edgedNodes = JSON.parse(JSON.stringify(selectedNodes));

        }
        updateStatus(edgedNodes);
        drawNetwork(edgedNodes);
    }*/


    function addSuperNodes() {
        for (var n in collapseMap) {
            if (!collapseMap[n])  // superNode
                selectedNodes.push(groupMap[n]);

        }
    }

    function filterNodes() {
        var metrics = ["degree", "betweenness", "pagerank", "community",
            "closeness_centrality", "eigenvector_centrality", 'clustering_coefficient'];

        toggleFociChecked = document.getElementById("toggleFociCB").checked;

        // replace community label 'foci' by '0'
        graph.nodes.forEach(function (node) {
            if (node.community.toString().toLowerCase().includes('foci'))
                node.community = 0;
            else {
                node.community = parseInt(node.community);
            }
        });

        nodesIndices = {};

        selectedNodes =
            graph.nodes.filter(function (node) {
                for (var metric in node) {
                    if (metrics.includes(metric)) {
                        if (metric.includes("community")) {
                            if (!(toggleFociChecked || !(node.screen_name.toString().toLowerCase().includes('sehir'))))
                                return false;
                        }
                        else {
                            var metricThreshold = parseFloat(document.getElementById(metric).value);
                            if (node[metric] < metricThreshold)
                                return false;
                        }
                    }
                }
                return (groupType.includes('None')) ? true : collapseMap[node[groupType]] === undefined || collapseMap[node[groupType]];
            });
        for (var n in selectedNodes) {
            nodesIndices[selectedNodes[n].id] = n;
        }

        addSuperNodes();
    }

    function fillGroups() {
        groupMap = {};
        groupIds.forEach(function (clickedGroupId) {
            var groupNodes = selectedNodes.filter(function (n) {
                return n[groupType] == clickedGroupId;
            });

            var superNode = {};
            var counter = {};
            groupNodes.sort(function (a, b) {
                b.betweenness - a.betweenness
            }).forEach(function (node) {
                for (var metric in node) {
                    var distributable = (
                        isNaN(node[metric]) || metric.includes('SCC') || metric.includes('community'));

                    if (metric.includes('name')) {
                        superNode[metric+'s'] = (superNode[metric+'s'] === undefined) ? "" : superNode[metric+'s'];
                        superNode[metric+'s'] += node[metric] + ", ";
                    }
                    else if (distributable) {
                        var v = node[metric].toString();
                        counter[metric] = (counter[metric] === undefined) ? {} : counter[metric];
                        counter[metric][v] = (counter[metric][v] === undefined) ? 0.0 : counter[metric][v];
                        counter[metric][v] += 1
                    }
                    else { // numeric metric
                        //superNode['avg_'+metric] = (superNode['avg_'+metric] === undefined) ? 0.0 : superNode['avg_'+metric];
                        //superNode['avg_'+metric] += node[metric];
                        superNode[metric] = (superNode[metric] === undefined) ? 0.0 : superNode[metric];
                        superNode[metric] += node[metric];
                    }
                }
            });

            var len = parseFloat(groupNodes.length);
            // Taking averages
            for (var metric in superNode) {
                if (!(metric.includes('name'))) { // numeric metric
                    superNode[metric] = parseFloat(superNode[metric]) / len;
                }
            }
            superNode[groupType] = clickedGroupId;
            // Reporting the distribution of the values of the nominal metrics
            for (var metric in counter) {
                if (metric.includes(groupType))
                    continue;

                var report = "";
                var reportVals = [];
                for (var metricVal in counter[metric]) {
                    var ratio = (parseFloat(counter[metric][metricVal]) * 100.0 / len).toFixed(2);
                    reportVals.push({'ratio': ratio, 'val': metricVal});
                }
                for (var r in
                    reportVals.sort(function (a, b) {  // sort in descending order
                        return b.ratio - a.ratio
                    })) {
                    report += reportVals[r].val + ": " + reportVals[r].ratio + "%, ";
                }
                //if (groupTypes.includes(metric))
                //superNode[metric] = report.split(":")[0];
                superNode[metric + "_dist"] = report;
            }
            /* Reporting the most dominant value of nominal metrics
                for (var metric in counter) {
                    var maxFreq = Number.NEGATIVE_INFINITY;
                    var maxVal;
                    for (var counterVal in counter[metric]) {
                        var freq = counter[metric][counterVal];

                        if (freq > maxFreq) {
                            maxFreq = freq;
                            maxVal = counterVal;
                        }
                    }

                    superNode[metric] = maxVal;

                }*/
            delete superNode.i;
            superNode.id = clickedGroupId;
            superNode.name = groupType + "_" + clickedGroupId;
            superNode.size = groupNodes.length;

            groupMap[superNode.id] = superNode;
        });


        collapseMap = (collapseMap === undefined) ? {} : collapseMap;

        selectedNodes.forEach(function (n) {
            if (groupType != 'None')
                collapseMap[n[groupType]] = (collapseMap[n[groupType]] === undefined) ? true : collapseMap[n[groupType]];
        });
    }


    function updatePaths() {
        svg.selectAll('.groups').remove();
        groups = svg.append('g').attr('class', 'groups');

        paths = groups.selectAll('.path_placeholder')
            .data(groupIds, function (d) {
                return +d;
            })
            .enter()
            .append('g')
            .attr('class', 'path_placeholder')
            .append('path')
            .attr('stroke', function (d) {
                return color(d);
            })
            .attr('fill', function (d) {
                return color(d);
            })
            .attr('opacity', 0);

        paths
            .transition()
            .duration(1000)
            .attr('opacity', 1);

        // add interaction to the groups
        groups.selectAll('.path_placeholder')
            .call(d3.drag()
                .on('start', group_dragstarted)
                .on('drag', group_dragged)
                .on('end', group_dragended)
            )
            .on("mouseover", function(d){
                d3.select(this).select('path').style("fill-opacity", 0.5).style('stroke-width', 3);
                groupOver(groupMap[d]);
            })
            .on("mouseout", function (d) {
                d3.select(this).select('path').style("fill-opacity", 0.2).style('stroke-width', 1);
                //document.getElementById("hoverInfo").innerHTML = '';
                d3.selectAll(".focus").remove();
            })
            .on("click", bundleNodes);
    }

    function updateGroupIds() {
        // count members of each group. Groups with less
        // than 3 member will not be considered (creating
        // a convex hull need 3 points at least)

        groupIds = d3.set(selectedNodes.map(function (n) {
            return +n[groupType];
        }))
            .values()
            .map(function (groupId) {
                return {
                    groupId: groupId,
                    count: selectedNodes.filter(function (n) {
                        return +n[groupType] == groupId;
                    }).length

                };
            })
            .filter(function (group) {
                return group.count > 2;
            })
            .map(function (group) {
                return group.groupId;
            });

        fillGroups();
    }

    function getGroupLinks(superNode) {
        var groupNodeIds = [];
        for (var n in selectedNodes) {
            var node = selectedNodes[n];
            if (node[groupType] == superNode.id) {
                groupNodeIds.push(node.id);
            }
        }

        var groupLinks = {};

        for (var _ in selectedLinks) {
            var l = selectedLinks[_];
            var source, target;

            source = groupNodeIds.includes(getLinkEnd(l.source)) ? superNode : l.source;
            target = groupNodeIds.includes(getLinkEnd(l.target)) ? superNode : l.target;

            if ((source == superNode || target == superNode) && source.id != target.id) { // they are not two connections in the same group
                var key = source.id.toString() + "-" + target.id.toString();
                if (groupLinks[key] === undefined) {
                    var link = {};
                    link['source'] = source;
                    link['target'] = target;
                    link['weight'] = 0;
                    groupLinks[key] = link;
                }
                else
                    groupLinks[key]['weight'] += 1;
            }
        }
        return groupLinks;
    }

    function updateGroupLinks(superNode, groupLinks) {
        updateLinks();  // filterNodes is called from inside updateLinks, Adding the superNode of the bundled nodes
        for (var key in groupLinks) {
            selectedLinks.push(groupLinks[key]);
        }
    }

    function groupOver(d) {
        document.getElementById("hoverInfo").innerHTML = '';
        document.getElementById("distInfo").innerHTML = '';
        d3.selectAll(".focus").remove();
        const isGroup = groupMap === undefined ? false : groupMap[d.id] !== undefined;
        var p;
        var intMetrics = ["SCC", "community", "id"];
        for (var metric in d) {
            var metricName;
            if (overhead.indexOf(metric) < 0 && !["fx","fy","x","y", "vx","vy", "index"].includes(metric)) {
                p = document.createElement("p");
                p.className = "hoverP";

                var val = isNaN(d[metric]) ? d[metric] :
                    (metric.includes("degree") || metric.includes("count")) || metric.includes("size") || intMetrics.includes(metric) ?
                        parseInt(d[metric]) : parseFloat(d[metric]).toFixed(8);
                if (metric.includes("names") || metric.includes('dist')){
                    var p2 = document.createElement("p");
                    metricName = metric.includes("names") ? metric.slice(0, -1) : metric.slice(0, -5);
                    metricName = "Largest "+metricName;
                    p2.textContent = metric + ": " + val;
                    document.getElementById("distInfo").appendChild(p2);
                    val = val.split(',')[0];
                    p.textContent = metricName + ": " + val;
                }
                else{

                    const numericMetricName = (["name", "size", "id", groupType].includes(metric)) ? metric:
                                        isGroup? "avg_"+metric:metric;
                    p.textContent = numericMetricName + ": " + val;
                }
                document.getElementById("hoverInfo").appendChild(p);
            }
        }

    }

    function bundleNodes(d, i) {
        /*
            Bundling steps:
            1- Get the corresponding superNode (i.e. the node representing the (community or SCC) of that group)
            2- Switch the collapse state of that group to false
            3- Remove the groupId from the groupIds so to remove the path (or the hull around the nodes of that group)
            4- Remove the group convex hull by updating paths with the updated groupIds
            5- Remove the info box of the superNode which was activated by mouseover event
            6- Get links between the superNode and other nodes in the network
            7- Remove all nodes in bundled groups
            8- Update network links to remove links between bundled sub-nodes and other nodes in the network
            9- Add the bundled superNode to selectedNodes
            9- Add links between the superNode and other nodes in the network
            10- Filter the bidirectional links according to its checkbox
            11- Filter edgeless nodes
            * */
        // Creating the superNode


        var superNode = groupMap[d];

        collapseMap[d] = collapseMap[d] ? false : true;  // toggle it

        if (!collapseMap[d]) {  // currently not bundled, bundle it
            //var index = groupIds.indexOf(d);
            //groupIds.splice(index, 1);

            d3.selectAll(".focus").remove();

            var groupLinks = getGroupLinks(superNode);

            {#updatePaths();#}
            {#updateGroupPolygons();#}

            updateGroupLinks(superNode, groupLinks);  // updating links and adding superNode are inside this function

            filterBidirEdges();
            filterEdgelessNodes();


        } else { // currently bundled, collapse it
            //updateGroupIds();
            {#updatePaths();#}
            {#updateGroupPolygons();#}
            updateLinks();  // filterNodes is called from inside updateLinks
        }

        drawNetwork();


    }


</script>


</body>
