<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<style>
    body {
        font-family: 'Times', cursive;
    }

    .hoverP {
        white-space: normal;
        width: 300px;
    }

    path {
        fill-opacity: .2;
        stroke-opacity: 1;
        stroke-width: 2;
    }

    .SideBar {
        width: 15%;
        height: 100%;
        display: none;
        background-color: #4C7EB7;
        color: white;
        overflow-y: auto;
    }

    html {
        height: 100%;
    }

    body {
        height: 100%;

    }

    .btn {
        background-color: transparent;
        border: none;
        color: black;
        cursor: pointer;
    }

    .btn:hover {
        color: grey;
    }

    .dropdownbtn {
        cursor: pointer;
        margin-bottom: 5px;
        border: none;
        color: white;
        size: 30px;
        width: 100%;
        background-color: #305177;
    }

    .dropdownbtn:hover {
        background-color: #173251;
    }

    table {
        width: 100%;
        background-color: #3571B5;
    }

    th {
        width: 100%;
        background-color: #8CB5E4;
    }

    .OptionsTable {
        align-content: center;
        width: 100%;
        display: none;
        table-layout: fixed;
    }

    .SubMenu {
        width: 100%;
        margin-bottom: 15px;
    }

    svg {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: 95%;
        z-index: 1;
        transition: 0.4s;
    }

</style>
<body>
<button class="btn" id="OpenSideBarButton" onclick="Open()"><i class="w3-jumbo fa fa-bars"></i></button>
<div class="SideBar" id="MainSideBar" style="float: left;">
    <button class="btn" style="float: right" onclick="Close()"><i class="w3-xxxlarge fa fa-close"></i></button>

    <div class="SubMenu">
        <button class="dropdownbtn" onclick="OpenSubMenu(1)" type="button">Find Nodes</button>
        <table class="OptionsTable" id="Sub_1">
            <tr>
                <th colspan="2"><input id="search" width='100%'></th>
            </tr>
            <tr>
                <th>
                    <button type="button" onclick="searchNode()">Find Node</button>
                </th>
                <th>
                    <button type="button" onclick="resetNodes()">Reset</button>
                </th>
            </tr>

        </table>
    </div>


    <div class="SubMenu">
        <button class="dropdownbtn" onclick="OpenSubMenu(2)" type="button">Network Visualization</button>
        <table class="OptionsTable" id="Sub_2">
            <tr>
                <div id="groupSettings">
                    <th>Group by:</th>
                    <th><select id="grp_set_drop" style="width: 100%"></select></th>
                </div>
            </tr>
            <tr>
                <div>
                    <th>Nodes size by:</th>
                    <th><select id="sizeBy" onchange="updateSize()" style="width: 100%">

                        {% for metric in size_metrics %}
                            <option value="{{ metric }}">{{ metric }}</option>
                        {% endfor %}
                    </select></th>
                </div>
            </tr>
            <tr>
                <th>Node scale:</th>
                <th><span id='nodeScaler'>100</span>
                    <input type="range" min="1" max="500" value="100" step="10" style="width: 100%"
                           oninput="sizeScaler= value; d3.select('#nodeScaler').text(sizeScaler); resetNodes()"></th>
            </tr>

            <tr>
                <th>Edge width:</th>
                <th><span id='edgeScaler'>1.0</span>
                    <input type="range" min="0.1" max="10" value="1.0" step="0.1" style="width: 100%"
                           oninput="esizeScaler= value; d3.select('#edgeScaler').text(esizeScaler); resetEdges()"></th>
            </tr>

            <tr>
                <th>Scale of the groups:</th>
                <th><span id='scaleFactorLabel'>1.2</span>
                    <input type="range" min="1" max="3" value="1.2" step=".1" style="width: 100%"
                           oninput="scaleFactor = value; d3.select('#scaleFactorLabel').text(scaleFactor); updateGroupPolygons()">
                </th>
            </tr>

            <tr>
                <th>Network's gravity:</th>
                <th><span id='gravityForce'>-600</span>
                    <input type="range" min="-5000" max="200" value="-600" step="10" style="width: 100%"
                           oninput="gravityForce = value; d3.select('#gravityForce').text(gravityForce); updateForce()">
                </th>
            </tr>
            <tr>
                <th>Include connection-less nodes</th>
                <th><input id="edgeLess" type="checkbox" title="include nodes with no connections"
                           onchange="filterEdgelessNodes(); drawNetwork();" checked></th>
            </tr>
            <tr>
                <th>Highlight edges on mouse-over</th>
                <th><input id="edgeInfo" type="checkbox" title="Show edge info when you hover over it"
                           onchange="edgeInfo=this.checked; toggleEdgeInfo();" checked></th>
            </tr>
        </table>
    </div>

    <div class="SubMenu">
        <button class="dropdownbtn" onclick="OpenSubMenu(3)" type="button">General Information</button>
        <table class="OptionsTable" id="Sub_3">
            <tr>
                <th>Nodes: <span id="num_nodes">{{ nodes_number }}</span></th>
            </tr>
            <tr>
                <th> Edges: <span
                        id="num_edges">{{ edges_number }}</span></th>
            </tr>
            <tr>
                <th>Communities: <span id="num_communities"></span></th>
            </tr>
            <tr>
                <th>SCCs: <span id="num_SCCs"></span></th>
            </tr>
            <tr>
                <th>Homophily: {{ homophily_value }} <br>( Heterogeneity: {{ heterogeneity }},
                    Threshold: {{ heterogeneity_threshold }})
                </th>
            </tr>
            <tr>
                <th>Transitivity: {{ transitivity_value }}</th>
            </tr>
        </table>
    </div>
    <form name="myForm" method="POST">


        <div class="SubMenu">
            <button class="dropdownbtn" onclick="OpenSubMenu(4)" type="button">Network Reconstruction</button>
            <table class="OptionsTable" id="Sub_4">
                {% csrf_token %}
                <tr>
                    <th id="textDate">
                        Date: {{ current_date }}</th>
                    <th><input type="range" id="date_scroller" name="date" min="0" max="{{ dates|length|add:"-1" }}"
                               step="1"
                               value="{{ date_index }}"
                               style="width: 100%"
                               onchange="updateDateText(this.value)">
                    </th>
                </tr>


                <tr>
                    <th>Recalculate node metrics:</th>
                    <th><input type="checkbox" id="recalculate_metrics" name="recalculate_metrics"></th>
                </tr>
                <tr>
                    <th>Recalculate communities:</th>
                    <th><input type="checkbox" id="recalculate_coms_checked" name="recalculate_coms_checked"></th>
                </tr>
                <tr>
                    <th>Include community accounts (e.g. clubs):</th>
                    <th><input type="checkbox" id="toggleFociCB" name="toggleFociCB"
                               oninput="updateLinks(); drawNetwork();"></th>
                </tr>
                <tr>
                    <th>Friendship (bidirectionals only):</th>
                    <th><input type="checkbox" id="toggleBidir" name="toggleBidir"
                               oninput="filterBidirEdges(); drawNetwork();"> {{ bidir_edges }}/{{ edges_number }}
                        ({{ bidir_ratio }}
                        %)
                    </th>
                </tr>
                <tr>
                    <th colspan="2"><input type="submit" value="Construct Network"></th>
                </tr>
            </table>
        </div>

        <div class="SubMenu">
            <button class="dropdownbtn" onclick="OpenSubMenu(5)" type="button">Parameters</button>
            <table class="OptionsTable" id="Sub_5">
                <tr>
                    <th>degree:</th>
                    <th><input type="text" id="text_degree" value="0" style="width: 100%"
                               name="text_degree"
                               onchange="updateScroll(this.value, 'degree')">{{ avg_degree }}</th>

                    <th>0<input id="degree"
                                type="range" value="0" min="0" max="100" step="1"
                                style="width: 100%"
                                onchange="updateText(this.value, 'text_degree')">100
                    </th>
                </tr>

                <tr>
                    <th>betweenness:</th>
                    <th><input type="text" id="text_betweenness" value="0" style="width: 50px"
                               name="text_betweenness"
                               onchange="updateScroll(this.value, 'betweenness')">{{ avg_betweenness }}</th>

                    <th>0.0<input id="betweenness"
                                  type="range" value="0" min="0.0" max="1.0" step="0.01"
                                  style="width: 100%"
                                  onchange="updateText(this.value, 'text_betweenness')">1.0
                    </th>
                </tr>
                <tr>
                    <th>pagerank:</th>
                    <th><input type="text" id="text_pagerank" value="0" style="width: 50px"
                               name="text_pagerank"
                               onchange="updateScroll(this.value, 'pagerank')">{{ avg_pagerank }}</th>

                    <th>0.0<input id="pagerank"
                                  type="range" value="0" min="0.0" max="1.0" step="0.01"
                                  style="width: 100%"
                                  onchange="updateText(this.value, 'text_pagerank')">1.0
                    </th>
                </tr>
                <tr>
                    <th>closeness:</th>
                    <th><input type="text" id="text_closeness_centrality" value="0" style="width: 50px"
                               name="text_closeness_centrality"
                               onchange="updateScroll(this.value, 'closeness_centrality')">{{ avg_closeness_centrality }}
                    </th>

                    <th>0.0<input id="closeness_centrality"
                                  type="range" value="0" min="0.0" max="1.0" step="0.01"
                                  style="width: 100%"
                                  onchange="updateText(this.value, 'text_closeness_centrality')">1.0
                    </th>
                </tr>

                <tr>
                    <Th>eigenvector:</Th>
                    <th><input type="text" id="text_eigenvector_centrality" value="0" style="width: 50px"
                               name="text_eigenvector_centrality"
                               onchange="updateScroll(this.value, 'eigenvector_centrality')">{{ avg_eigenvector_centrality }}
                    </th>

                    <th>0.0<input id="eigenvector_centrality"
                                  type="range" value="0" min="0.0" max="1.0" step="0.01"
                                  style="width: 100%"
                                  onchange="updateText(this.value, 'text_eigenvector_centrality')">1.0
                    </th>

                </tr>
                <tr>
                    <th>Clustering Coefficient:</th>
                    <th><input type="text" id="text_clustering_coefficient" value="0"
                               style="width: 50px"
                               name="text_clustering_coefficient"
                               onchange="updateScroll(this.value, 'clustering_coefficient')">{{ avg_clustering_coefficient }}
                    </th>

                    <th>0.0<input id="clustering_coefficient"
                                  type="range" value="0" min="0.0" max="1.0" step="0.01"
                                  style="width: 100%"
                                  onchange="updateText(this.value, 'text_clustering_coefficient')">1.0
                    </th>

                </tr>
            </table>
        </div>
    </form>


</div>

<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">

<svg id="svg"></svg>

<div id="MainInfo" style= "height: 100%;">

</div>
</div>

<div id="distInfo" style="clear: both"></div>
</body>


<script>
    var TabsOpen = [false, false, false, false, false];

    //Open side bar
    function Open() {
        document.getElementById("OpenSideBarButton").style.display = "none";
        document.getElementById("MainSideBar").style.width = "15%";
        document.getElementById("svg").style.width = "85%";
        document.getElementById("MainSideBar").style.display = "block";
    }

    function Close() {
        document.getElementById("OpenSideBarButton").style.display = "block";
        document.getElementById("MainSideBar").style.width = "0%";
        document.getElementById("svg").style.width = "95%";
        document.getElementById("MainSideBar").style.display = "none";
    }

    function OpenSubMenu(SubMenu) {
        var ItemName = "Sub_" + SubMenu.toString();
        var disp = "none";
        if (!TabsOpen[SubMenu])
            disp = "table";

        document.getElementById(ItemName).style.display = disp;
        document.getElementById(ItemName).style.width = "100%";

        TabsOpen[SubMenu] = !TabsOpen[SubMenu];
    }

    document.getElementById("recalculate_metrics").checked = {{recalculate_checked}};
    document.getElementById("recalculate_coms_checked").checked = {{recalculate_coms_checked}};
    document.getElementById("toggleFociCB").checked = {{foci_checked}};
    document.getElementById("toggleBidir").checked = {{bidir}};

    d3.select("svg").attr("width", window.screen.height)
        .attr("height", window.screen.height - 200);

    // d3.select("svg").attr("width", 960)
    //     .attr("height", 500);

    const overhead = ["index", "x", "y", "vy", "vx", "fx", "fy"];

    var svg2 = d3.select("svg"),
        width = +svg2.attr("width"),
        height = +svg2.attr("height"),
        transform = d3.zoomIdentity;

    var svg = svg2.append("g");

    var zoom = d3.zoom()
        .scaleExtent([1 / 16, 8])
        .on("zoom", zoomed);

    svg2.call(zoom);

    zoom.scaleTo(svg2, 1 / 4);

    function zoomed() {
        svg.attr("transform", d3.event.transform);
    }

    var node,
        link,
        label,
        is_directed,
        communitiesSet,
        valueline = d3.line()
            .x(function (d) {
                return d[0];
            })
            .y(function (d) {
                return d[1];
            })
            .curve(d3.curveCatmullRomClosed),
        collapseMap,
        edgeInfo,
        toggleFociChecked,
        groupMap,
        nodesIndices,
        groupOutLinks,
        groupInLinks,
        selectedNodes,
        selectedLinks,
        unidirEdges,
        edgelessNodes,
        paths,
        groups,
        groupIds,
        scaleFactor = 1.2,
        gravityForce = -600,
        sizeScaler = 100,
        esizeScaler = 1,
        polygon,
        centroid,
        graph,
        color = d3.scaleOrdinal({{ colors|safe }}),
        size_metric, avgSize, maxSize, minSize,
        groupTypes = ["None", "SCC", "community"],
        groupType = "None",
        simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function (d) {
                return d.id;
            }))
            .force("charge", d3.forceManyBody().strength(gravityForce))
            .force("center", d3.forceCenter(width / 2, height / 2));

    is_directed = true;  // TODO set checkbox for that
    //color = d3.scaleOrdinal(d3.schemeCategory20);
    {#var curveTypes = ['curveBasisClosed', 'curveCardinalClosed', 'curveCatmullRomClosed', 'curveLinearClosed'],#}

    {#selectedDegree = document.getElementById('degree').value;#}

    {#drawNetwork(selectedDegree, is_directed);#}
    initNetwork();

    var fr = {};

    function initNetwork() {
        d3.json("{% url 'Twitter:load_twitter_connections_json' %}", function (error, g) {
            if (error) throw error;

            graph = g;
            simulation.alphaTarget(0.0).restart();
            d3.selectAll('.select_group').remove();

            if (selectedNodes === undefined) {  // first run
                selectedNodes = JSON.parse(JSON.stringify(graph.nodes));
                updateGraphLinks();
                updateLinks();
            }

            d3.select('#grp_set_drop')
                .attr('class', 'select_group')
                .on('change', function () {
                    var val = d3.select('.select_group').property('value');

                    groupType = val;
                    {#valueline.curve(d3[val]);#}
                    if (fr[groupType] === undefined) {
                        updateGroupIds();
                        fr[groupType] = {"ids": groupIds, "groupMap": groupMap};
                        var i = 0;
                        groupIds.forEach(function (d) {
                            i += 1;
                        });
                        console.log(groupType, i)
                    } else {
                        console.log("LOADING:", groupType, "Stats");
                        groupIds = fr[groupType]["ids"];
                        groupMap = fr[groupType]["groupMap"];
                    }
                    updatePaths();
                    updateGroupPolygons();
                })
                .selectAll('option')
                .data(groupTypes).enter()
                .append('option')
                .text(function (d) {
                    return d;
                });


            // create groups, links and nodes
            groups = svg.append('g').attr('class', 'groups');

            /*communitiesSet.forEach(function (c){
               colors.push(getRandomColor());
            });*/

            /*if (communitiesSet.size > colors.length) {
                for (var i = 0; i < Math.max(communitiesSet.size, 50); i++)  // add more 50 colors
                    colors.push(getRandomColor());
            }

            color = d3.scaleOrdinal(colors);*/
            drawNetwork();
        });

    }

    function toggleEdgeInfo() {
        if (edgeInfo) {
            svg.selectAll("line")
                .on("mouseover", function (d) {
                    d3.select(this).style("stroke-width", link_over);
                    const focus = svg.append('g')
                        .attr('class', 'focus');
                    const cx = svg2.mouse(this)[0];
                    const cy = svg2.mouse(this)[1];
                    focus.append('rect')
                        .attr('height', 180)
                        .attr('width', 300)
                        .style("stroke-width", "0.05")
                        .attr("x", cx)
                        .attr("y", cy);
                    var x = 0.0;
                    for (var metric in d) {
                        var s;
                        if (metric == "weight") {
                            s = d[metric];
                        }
                        else {
                            s = d[metric].name;
                        }
                        if (overhead.indexOf(metric) < 0) {
                            x += 1.2;
                            metric = metric.includes("weight") || (!document.getElementById("toggleBidir").checked) ?
                                metric : "node";
                            focus.append('text')
                                .attr('x', cx)
                                .attr('y', cy)
                                .attr('dy', x + 'em')
                                .attr('dx', '.5em')
                                .style("font-size", 30)
                                .text(metric + ": " + s);
                        }
                    }
                    d3.select('.overlay')
                        .styles({
                            fill: 'none',
                            'pointer-events': 'all'
                        });
                    d3.selectAll('.focus')
                        .style('opacity', 0.9);
                    d3.selectAll('.focus rect')
                        .styles({
                            fill: '#CFEEF1',
                            stroke: 'black'
                        });
                })
                .on("mouseout", function (d) {
                    d3.select(this).style("stroke-width", link_weight);
                    d3.selectAll(".focus").remove();
                });
        }
        else {

            svg.selectAll("line").on("mouseover", null);
        }
    }

    function drawNetwork() {
        svg.selectAll(".links").remove();
        svg.selectAll(".nodes").remove();
        svg.selectAll(".labels").remove();

        if (groupType != 'None') {
            updatePaths();
            updateGroupPolygons();
        }
        if (!document.getElementById("toggleBidir").checked) {
            svg.append('defs').append('marker')
                .attrs({
                    'id': 'arrowhead',
                    'viewBox': '-0 -5 10 10',
                    'refX': 13,
                    'refY': 0,
                    'orient': 'auto',
                    'markerWidth': 10,
                    'markerHeight': 10,
                    'xoverflow': 'visible'
                })
                .append('svg:path')
                .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                .attr('fill', '#999')
                .style('stroke', 'none');

        }

        link = svg.append("g")
            .style("stroke", "#aaa")
            .style("stroke-opacity", "0.8")
            .attr("class", "links")
            .selectAll("line")
            .data(selectedLinks)
            .enter().append("line")
            .attr('marker-end', 'url(#arrowhead)');


        node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(selectedNodes)
            .enter().append("circle")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(selectedNodes)
            .enter().append("text")
            .attr("class", "label");
        // .text(function(d){return d.id;});


        updateStatus();
        updateSize();

        svg.selectAll("circle")
            .on("mouseover", function (d) {
                var z = d3.zoomTransform(svg2.node()).k;

                d3.select(this).style("r", node_over);
                d3.select(this).style("fill-opacity", 0.9).style('stroke-width', 3);

                const focus = svg.append('g')
                    .attr('class', 'focus');
                const cx = d3.select(this).attr("cx");
                const cy = d3.select(this).attr("cy");

                focus.append('rect')
                    .attr('height', 220/z)
                    .attr('width', 550/z)
                    .attr("x", cx)
                    .attr("y", cy);
                var x = 0.0;
                var displayMetrics;
                var toGroupOver = false;
                if (groupMap === undefined || groupMap[d.id] === undefined) {
                    displayMetrics = ["screen_name", "lang", "followers_count", "degree", "community"];
                } else {
                    displayMetrics = ["name", "community", "size"];
                    toGroupOver = true;
                }
                displayMetrics.forEach(function (metric) {

                    if (overhead.indexOf(metric) < 0) {
                        x += 1.2;
                        var val = isNaN(d[metric]) ? d[metric] :
                            (metric.includes("degree") || metric.includes("count") || groupTypes.includes(metric)) ? parseInt(d[metric]) :
                                parseFloat(d[metric]).toFixed(4);
                        focus.append('text')
                            .attr('x', cx + 5)
                            .attr('y', cy + 5)
                            .attr('dy', x + 'em')
                            .attr('dx', '.5em')
                            .style("font-size", 30/z)
                            .text(metric + ": " + val);
                    }
                });

                d3.select('.overlay')
                    .styles({
                        fill: 'none',
                        'pointer-events': 'all'
                    });

                d3.selectAll('.focus')
                    .style('opacity', 0.9);

                d3.selectAll('.focus rect')
                    .styles({
                        fill: '#CFEEF1',
                        stroke: 'black'
                    });
                if (toGroupOver)
                    groupOver(groupMap[d.id]);
            })
            .on("mouseout", function (d) {
                d3.select(this).style("r", node_scale).style("fill-opacity", 0.7).style('stroke-width', 2);
                d3.selectAll(".focus").remove();
            })
            .on("click", function (d) {
                if (groupMap === undefined) {
                    groupOver(d);
                }
                else if (groupMap[d] === undefined) {
                    if (groupMap[d.id] === undefined) {
                        groupOver(d);
                    }
                    else {
                        bundleNodes(d.id);
                    }
                }
                else {
                    bundleNodes(d);
                }
            });

        svg.selectAll("line")
            .on("mouseover", function (d) {
                var z = d3.zoomTransform(svg2.node()).k;
                d3.select(this).style("stroke-width", link_over);
                const focus = svg.append('g')
                    .attr('class', 'focus');
                const cx = d3.mouse(this)[0];
                const cy = d3.mouse(this)[1];
                focus.append('rect')
                    .attr('height', 180/z)
                    .attr('width', 300/z)
                    .style("stroke-width", "0.05")
                    .attr("x", cx)
                    .attr("y", cy);
                var x = 0.0;
                for (var metric in d) {
                    var s;
                    if (metric == "weight") {
                        s = d[metric];
                    }
                    else {
                        s = d[metric].name;
                    }
                    if (overhead.indexOf(metric) < 0) {
                        x += 1.2;
                        metric = metric.includes("weight") || (!document.getElementById("toggleBidir").checked) ?
                            metric : "node";
                        focus.append('text')
                            .attr('x', cx)
                            .attr('y', cy)
                            .attr('dy', x + 'em')
                            .attr('dx', '.5em')
                            .style("font-size", 30/z)
                            .text(metric + ": " + s);
                    }
                }
                d3.select('.overlay')
                    .styles({
                        fill: 'none',
                        'pointer-events': 'all'
                    });
                d3.selectAll('.focus')
                    .style('opacity', 0.9);
                d3.selectAll('.focus rect')
                    .styles({
                        fill: '#CFEEF1',
                        stroke: 'black'
                    });
            })
            .on("mouseout", function (d) {
                d3.select(this).style("stroke-width", link_weight);
                d3.selectAll(".focus").remove();
            });

        simulation
            .nodes(selectedNodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(selectedLinks);

        function ticked() {

            link
                .attr('x1', d => d.source.x
        )
        .
            attr('y1', d => d.source.y
        )
        .
            attr('x2', d => d.target.x
        )
        .
            attr('y2', d => d.target.y
        )
            ;

            node
                .attr("r", node_scale)
                .attr('cx', d => d.x
        )
        .
            attr('cy', d => d.y
        )
        .
            style('fill-opacity', 0.7)
                .style('fill', function (d) {
                        if (groupType == "SCC" && groupMap[d.id] != undefined)
                            return color(parseInt(d.SCC));
                        else
                            return color(parseInt(d.community))
                    }
                )
                .style('stroke', "none");

            label
                .attr("x", d => d.x
        )
        .
            attr("y", d => d.y
        )
        .
            style("font-size", "10px")
                .style("fill", "#4393c3")
                .text(function (d) {
                    return (groupMap === undefined || groupMap[d.id] === undefined) ?
                        d.screen_name : d.name;
                })
            ;

            updateGroupPolygons();
        }
    }

    /*function restartNetwork(_nodes, _links){

        if (_nodes === undefined)
            _nodes = JSON.parse(JSON.stringify(selectedNodes));

        if (_links === undefined)
            _links = JSON.parse(JSON.stringify(selectedLinks));

        node = node.data(_nodes);
        node.exit().remove();

        link = link.data(_links);
        link.exit().remove();

        label = label.data(_nodes);
        label.exit().remove();

        simulation.nodes(_nodes);
        simulation.force("link")
            .links(_links);

    }*/


    // .domain([{{minSize}},{{maxSize}}])
    // .range([1, 50]);
    function node_scale(d) {
        var size = (d.size === undefined) ? d[size_metric] : d[size_metric] * (Math.min(d.size, 20.0));
        return Math.max((Math.abs(size - avgSize)) / (maxSize - minSize) * sizeScaler, sizeScaler / 20);
    }

    function node_over(d) {
        var size = (d.size === undefined) ? d[size_metric] : d[size_metric] * (Math.min(d.size, 20.0));
        return Math.max((Math.abs(size - avgSize)) / (maxSize - minSize) * (sizeScaler * 1.8), sizeScaler * 2);
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }


    // drag groups
    function group_dragstarted(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 3);
    }

    function group_dragged(groupId) {
        node
            .filter(function (d) {
                return d[groupType] == groupId;
            })
            {#.filter(function(d) { return d['SCC'] == groupId; })#}
            .each(function (d) {
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            })
    }

    function group_dragended(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0).restart();
        d3.select(this).select('path').style('stroke-width', 1);
    }

    /*var seed = 120;

    function random() {
        var x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    }


    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            //color += letters[Math.floor(Math.random() * 16)];
            color += letters[Math.floor(random() * 16)];
        }
        return color;
    }*/

    function link_weight(d) {
        if (d.weight === undefined) {
            d.weight = 1.0;
        }
        return Math.max(d.weight * esizeScaler, 1.0).toString();
    }

    function link_over(d) {
        if (d.weight === undefined) {
            d.weight = 1.0;
        }
        return Math.max(d.weight * esizeScaler, 1.0) * 5.0.toString();
    }

    function searchNode() {
        var selectedVal = document.getElementById('search').value;
        if (selectedVal == 'none') {
        }
        else {
            var selected = node.filter(function (d, i) {
                if (d.screen_name !== undefined) {
                    if (d.screen_name.includes(selectedVal))
                        return true;
                }
                else if (d.match_name !== undefined) {
                    if (d.match_name.includes(selectedVal))
                        return true;
                }
                else if (d.name !== undefined) {
                    if (d.name.includes(selectedVal))
                        return true;
                }
                return false;
            });

            var nonselected = node.filter(function (d, i) {
                if (d.screen_name !== undefined) {
                    if (d.screen_name.includes(selectedVal))
                        return false;
                }
                else if (d.match_name !== undefined) {
                    if (d.match_name.includes(selectedVal))
                        return false;
                }
                else if (d.name !== undefined) {
                    if (d.name.includes(selectedVal))
                        return false;
                }
                return true;
            });
            nonselected.style("opacity", "0.1");
            selected.style("opacity", 1.0);
            selected.style("r", node_over);
            alert("Found: " + selected.size().toString());
            centerNode(selected.attr("cx"), selected.attr("cy"));

            // var link = svg.selectAll(".link");
            // link.style("opacity", "0");
            d3.selectAll(".node, .link").transition()
                .duration(3000)
                .style("opacity", '1');
        }

    }


    /*
    function resetBundling() {
        filterNodes();
        updateGraphLinks();
        filterBidirEdges();
        drawNetwork();
    }*/

    function resetEdges() {
        var all_edges = link.filter(function (d, i) {
            return true;
        });
        all_edges.style("stroke-width", link_weight);
    }

    function resetNodes() {
        var all_nodes = node.filter(function (d, i) {
            return true;
        });

        all_nodes.style("r", node_scale)
            .style("opacity", 0.7);
    }

    function updateText(threshold, widget) {
        {#var metric = widget.slice(5);  // text_degree => degree  (removing 'text_')#}

        document.getElementById(widget).value = threshold;
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }

    function updateScroll(threshold, widget) {

        document.getElementById(widget).value = threshold;
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }

    function centerNode(xx, yy) {
        svg.transition()
            .duration(500)
            .attr("transform", "translate(" + (width / 2 - xx) + "," + (height / 2 - yy) + ")scale(" + 1 + ")")
            .on("end", function () {
                svg2.call(zoom.transform, d3.zoomIdentity.translate((width / 2 - xx), (height / 2 - yy)).scale(1))
            });
    }

    function updateDateText(date_index) {
        var dates = {{dates_dumped|safe}};
        document.getElementById("textDate").innerHTML = "Date: " + dates[date_index].toString();
    }


    // select nodes of the group, retrieve its positions
    // and return the convex hull of the specified points
    // (3 points as minimum, otherwise returns null)
    var polygonGenerator = function (groupId) {
        var node_coords = node
            .filter(function (d) {
                return d[groupType] == groupId;
            })
            .data()
            .map(function (d) {
                return [d.x, d.y];
            });

        return d3.polygonHull(node_coords);
    };


    function updateForce() {
        simulation.force("charge", d3.forceManyBody().strength(gravityForce));

    }

    function updateSize() {
        size_metric = document.getElementById("sizeBy").value;
        avgSize = 0;
        maxSize = Number.NEGATIVE_INFINITY;
        minSize = Number.POSITIVE_INFINITY;

        selectedNodes.forEach(function (d) {
            avgSize += d[size_metric];
            maxSize = Math.max(maxSize, d[size_metric]);
            minSize = Math.min(maxSize, d[size_metric]);
        });
        avgSize /= selectedNodes.length;

        resetNodes();
    }

    function updateGroupPolygons() {
        if (!((groupIds === undefined) || (groupIds == null))) {
            try {
                groupIds.forEach(function (groupId) {
                    if (collapseMap[groupId]) {
                        var path = paths.filter(function (d) {
                            return collapseMap[d] ? d == groupId : false;
                            // return d == groupId;
                        });
                        path.attr('transform', 'scale(1) translate(0,0)')
                            .attr('d', function (d) {
                                polygon = polygonGenerator(d);
                                centroid = d3.polygonCentroid(polygon);

                                // to scale the shape properly around its points:
                                // move the 'g' element to the centroid point, translate
                                // all the path around the center of the 'g' and then
                                // we can scale the 'g' element properly
                                return valueline(
                                    polygon.map(function (point) {
                                        return [point[0] - centroid[0], point[1] - centroid[1]];
                                    })
                                );
                            });


                        d3.select(path.node().parentNode).attr('transform', 'translate(' + centroid[0] + ',' + (centroid[1]) + ') scale(' + scaleFactor + ')');
                    }
                });
            } catch (err) {
                console.log("ERROR:", err);
            }
        }
    }

    function countCommunities(group, minSize=1) {
        var groupSizes = {};
        if (group.includes("community") && groupType.includes("community"))
            communitiesSet = new Set([]);
        selectedNodes.forEach(function (node) {
            var id = node[group];
            if (id !== undefined) {
                groupSizes[id] = groupSizes[id] === undefined ? 0 : groupSizes[id];
                groupSizes[id] += 1;
                if (group.includes("community") && groupType.includes("community"))
                    communitiesSet.add(id);
            }
        });
        var count = 0;
        for (var g in groupSizes) {
            if ((groupSizes[g] >= minSize) || (group === groupType && (!collapseMap[g])))
                count += 1;
        }
        return count;

    }

    function getLinkEnd(n) {
        if (typeof n == 'number')
            return n;
        else
            return parseInt(n.id);
    }

    function updateLinks() {
        filterNodes();
        selectedLinks = graph.links.filter(function (l) {
            var valid = 0;  // check if both ends of the connection are in selectedNodes

            for (var n in selectedNodes) {
                var node_id = getLinkEnd(selectedNodes[n]);
                var source_id = getLinkEnd(l.source);
                var target_id = getLinkEnd(l.target);


                {#console.log(node_id, source_id, l.source);#}

                if (node_id === source_id)
                    valid += 1;
                if (node_id === target_id)
                    valid += 1;
                if (valid > 1)
                    return true;
            }
            return false;
            {#return selectedNodes.includes(link.source) && selectedNodes.includes(link.target);#}
        });

        filterBidirEdges();
        filterEdgelessNodes();

        updateStatus();
    }

    function updateGraphLinks() {

        graph.links.forEach(function (d) {
            d.source = d.source;
            d.target = d.target;
        });

        selectedLinks = JSON.parse(JSON.stringify(graph.links));
    }

    function filterBidirEdges() {
        if (document.getElementById("toggleBidir").checked) {
            var bidirEdges = selectedLinks.filter(function (l1) {
                for (var l2_ in selectedLinks) {
                    var l2 = selectedLinks[l2_];
                    {#console.log(l1.source, l2.source);#}
                    if ((getLinkEnd(l1.source) == getLinkEnd(l2.target)) && (getLinkEnd(l2.source) == getLinkEnd(l1.target)))
                        return true;
                }
                return false;
            });
            unidirEdges = selectedLinks.filter(function (l1) {
                for (var l2_ in selectedLinks) {
                    var l2 = selectedLinks[l2_];
                    {#console.log(l1.source, l2.source);#}
                    if ((getLinkEnd(l1.source) == getLinkEnd(l2.target)) && (getLinkEnd(l2.source) == getLinkEnd(l1.target)))
                        return false;
                }
                return true;
            });
            selectedLinks = bidirEdges;
        }
        else if (unidirEdges !== undefined) {
            unidirEdges.forEach(function (l) {
                selectedLinks.push(l);
            })
        }
    }


    function updateStatus() {
        var comCount = countCommunities("community");
        var sccCount = countCommunities("SCC", 2);
        d3.select("#num_nodes").text(selectedNodes.length.toString());
        d3.select("#num_edges").text(selectedLinks.length.toString());
        d3.select("#num_communities").text(comCount.toString());
        d3.select("#num_SCCs").text(sccCount.toString());
    }


    function filterEdgelessNodes() {
        if (!document.getElementById("edgeLess").checked) {
            var edgedNodes = selectedNodes.filter(function (n) {
                for (var l_ in selectedLinks) {
                    var l = selectedLinks[l_];
                    if ((getLinkEnd(l.source) == n.id) || (getLinkEnd(l.target) == n.id))
                        return true;
                }
                return false;
            });
            edgelessNodes = selectedNodes.filter(function (n) {
                for (var l_ in selectedLinks) {
                    var l = selectedLinks[l_];
                    if ((getLinkEnd(l.source) == n.id) || (getLinkEnd(l.target) == n.id))
                        return false;
                }
                return true;
            });

            selectedNodes = edgedNodes;

        }
        else if (edgelessNodes != undefined) {
            edgelessNodes.forEach(function (d) {
                selectedNodes.push(d);
            })
        }
    }


    /*function toggleEdgeLessNodes(){
        var edgeLessCB = document.getElementById("edgeLess").checked;
        var edgedNodes;
        if (!edgeLessCB) {
            edgedNodes = selectedNodes.filter(function (n) {
                for (var l_ in selectedLinks) {
                    var l = selectedLinks[l_];
                    if ((getLinkEnd(l.source) == n.id) || (getLinkEnd(l.target) == n.id)) {
                        return true;
                    }
                }
                return false;
            });
        }else{
            edgedNodes = JSON.parse(JSON.stringify(selectedNodes));

        }
        updateStatus(edgedNodes);
        drawNetwork(edgedNodes);
    }*/


    function addSuperNodes() {
        for (var n in collapseMap) {
            if (!collapseMap[n])  // superNode
                selectedNodes.push(groupMap[n]);

        }
    }

    function isSelected(id) {
        var selected = selectedNodes.filter(function (d) {
            return d.id == id;
        });
        return selected.length;
    }

    function filterNodes() {
        var metrics = ["degree", "betweenness", "pagerank", "community",
            "closeness_centrality", "eigenvector_centrality", 'clustering_coefficient'];

        toggleFociChecked = document.getElementById("toggleFociCB").checked;

        // replace community label 'foci' by '0'
        graph.nodes.forEach(function (node) {
            if (node.community.toString().toLowerCase().includes('foci'))
                node.community = 0;
            else {
                node.community = parseInt(node.community);
            }
        });

        nodesIndices = {};

        selectedNodes =
            graph.nodes.filter(function (node) {
                for (var metric in node) {
                    if (metrics.includes(metric)) {
                        if (metric.includes("community")) {
                            if (!(toggleFociChecked || !(node.screen_name.toString().toLowerCase().includes('sehir'))))
                                return false;
                        }
                        else {
                            var metricThreshold = parseFloat(document.getElementById(metric).value);
                            if (node[metric] < metricThreshold)
                                return false;
                        }
                    }
                }
                return (groupType.includes('None')) ? true : collapseMap[node[groupType]] === undefined || collapseMap[node[groupType]];
            });
        for (var n in selectedNodes) {
            nodesIndices[selectedNodes[n].id] = n;
        }

        addSuperNodes();
    }

    function fillGroups() {
        groupMap = {};
        groupIds.forEach(function (clickedGroupId) {
            var groupNodes = selectedNodes.filter(function (n) {
                return n[groupType] == clickedGroupId;
            });

            var superNode = {};
            var counter = {};
            groupNodes.sort(function (a, b) {
                b.betweenness - a.betweenness
            }).forEach(function (node) {
                for (var metric in node) {
                    var distributable = (
                        isNaN(node[metric]) || metric.includes('SCC') || metric.includes('community'));

                    if (metric.includes('name')) {
                        superNode[metric + 's'] = (superNode[metric + 's'] === undefined) ? "" : superNode[metric + 's'];
                        superNode[metric + 's'] += node[metric] + ", ";
                    }
                    else if (distributable) {
                        var v = node[metric].toString();
                        counter[metric] = (counter[metric] === undefined) ? {} : counter[metric];
                        counter[metric][v] = (counter[metric][v] === undefined) ? 0.0 : counter[metric][v];
                        counter[metric][v] += 1
                    }
                    else { // numeric metric
                        //superNode['avg_'+metric] = (superNode['avg_'+metric] === undefined) ? 0.0 : superNode['avg_'+metric];
                        //superNode['avg_'+metric] += node[metric];
                        superNode[metric] = (superNode[metric] === undefined) ? 0.0 : superNode[metric];
                        superNode[metric] += node[metric];
                    }
                }
            });

            var len = parseFloat(groupNodes.length);
            // Taking averages
            for (var metric in superNode) {
                if (!(metric.includes('name'))) { // numeric metric
                    superNode[metric] = parseFloat(superNode[metric]) / len;
                }
            }
            superNode[groupType] = clickedGroupId;
            // Reporting the distribution of the values of the nominal metrics
            for (var metric in counter) {
                if (metric.includes(groupType))
                    continue;

                var report = "";
                var reportVals = [];
                for (var metricVal in counter[metric]) {
                    var ratio = (parseFloat(counter[metric][metricVal]) * 100.0 / len).toFixed(2);
                    reportVals.push({'ratio': ratio, 'val': metricVal});
                }
                for (var r in
                    reportVals.sort(function (a, b) {  // sort in descending order
                        return b.ratio - a.ratio
                    })) {
                    report += reportVals[r].val + ": " + reportVals[r].ratio + "%, ";
                }
                //if (groupTypes.includes(metric))
                //superNode[metric] = report.split(":")[0];
                superNode[metric + "_dist"] = report;
            }
            /* Reporting the most dominant value of nominal metrics
                for (var metric in counter) {
                    var maxFreq = Number.NEGATIVE_INFINITY;
                    var maxVal;
                    for (var counterVal in counter[metric]) {
                        var freq = counter[metric][counterVal];

                        if (freq > maxFreq) {
                            maxFreq = freq;
                            maxVal = counterVal;
                        }
                    }

                    superNode[metric] = maxVal;

                }*/
            delete superNode.i;
            superNode.id = clickedGroupId;
            superNode.name = groupType + "_" + clickedGroupId;
            superNode.size = groupNodes.length;

            groupMap[superNode.id] = superNode;
        });


        collapseMap = (collapseMap === undefined) ? {} : collapseMap;

        selectedNodes.forEach(function (n) {
            if (groupType != 'None')
                collapseMap[n[groupType]] = (collapseMap[n[groupType]] === undefined) ? true : collapseMap[n[groupType]];
        });
    }


    function updatePaths() {
        svg.selectAll('.groups').remove();
        groups = svg.append('g').attr('class', 'groups');

        paths = groups.selectAll('.path_placeholder')
            .data(groupIds, function (d) {
                return +d;
            })
            .enter()
            .append('g')
            .attr('class', 'path_placeholder')
            .append('path')
            .attr('stroke', function (d) {
                return color(parseInt(groupMap[d][groupType]));
            })
            .attr('fill', function (d) {
                return color(parseInt(groupMap[d][groupType]));
            })
            .attr('opacity', 0);

        paths
            .transition()
            .duration(1000)
            .attr('opacity', 1);

        // add interaction to the groups
        groups.selectAll('.path_placeholder')
            .call(d3.drag()
                .on('start', group_dragstarted)
                .on('drag', group_dragged)
                .on('end', group_dragended)
            )
            .on("mouseover", function (d) {
                d3.select(this).select('path').style("fill-opacity", 0.5).style('stroke-width', 3);
                groupOver(groupMap[d]);
            })
            .on("mouseout", function (d) {
                d3.select(this).select('path').style("fill-opacity", 0.2).style('stroke-width', 1);
                //document.getElementById("hoverInfo").innerHTML = '';
                d3.selectAll(".focus").remove();
            })
            .on("click", bundleNodes);
    }

    function updateGroupIds() {
        // count members of each group. Groups with less
        // than 3 member will not be considered (creating
        // a convex hull need 3 points at least)

        groupIds = d3.set(selectedNodes.map(function (n) {
            return +n[groupType];
        }))
            .values()
            .map(function (groupId) {
                return {
                    groupId: groupId,
                    count: selectedNodes.filter(function (n) {
                        return +n[groupType] == groupId;
                    }).length

                };
            })
            .filter(function (group) {
                return group.count > 2;
            })
            .map(function (group) {
                return group.groupId;
            });

        fillGroups();
    }

    function getGroupNodes(superNode) {
        var groupNodes = [];
        for (var n in selectedNodes) {
            var node = selectedNodes[n];
            if (node[groupType] == superNode.id) {
                groupNodes.push(node.id);
            }
        }
        return groupNodes;
    }

    function updateAllGroupLinks() {
        console.log("LOADING GROUP LINKS");
        groupOutLinks = {};  // {community : [nodes connected FROM the community Community -> node]}
        groupInLinks = {};  // {community : [nodes connecting TO the community node -> Community]}
        selectedLinks.forEach(function (link) {
            var source = link.source;
            var sourceGroup = source[groupType];

            var target = link.target;
            var targetGroup = target[groupType];


            if (groupMap != undefined && sourceGroup != targetGroup) {
                groupOutLinks[sourceGroup] = groupOutLinks[sourceGroup] === undefined ? [] : groupOutLinks[sourceGroup];
                groupOutLinks[sourceGroup].push(target);

                groupInLinks[targetGroup] = groupInLinks[targetGroup] === undefined ? [] : groupInLinks[targetGroup];
                groupInLinks[targetGroup].push(source);
            }
        })
    }


    function addLinks(inputLinks, isOut) {
        for (var community in inputLinks) {
            if (isSelected(community) < 1)
                continue;
            //console.log("LOOKING AT",community);
            var outLinks = inputLinks[community];
            var glinks = {};

            for (var i in outLinks) {
                var n = outLinks[i];

                n = isSelected(n.id) ? n : groupMap[n[groupType]];  // Either a normal node or a bundled node

                var key = document.getElementById("toggleBidir").checked ? [community, n.id].sort(
                    function (a, b) {
                        return b - a;
                    }).toString() : [community.toString() + "," + n.id.toString()];

                var newLink;
                if (isOut)
                    newLink = {"source": groupMap[community], "target": n, "weight": 0};
                else
                    newLink = {"source": n, "target": groupMap[community], "weight": 0};

                glinks [key] = glinks [key] === undefined ? newLink : glinks [key];
                glinks [key]["weight"] += 1;

            }

            for (var key in glinks) {
                selectedLinks.push(glinks[key]);
            }

            /*for (var n in counter){
                console.log(n, counter[n]);
                var link = {"source":groupMap[community], "target":groupMap[n], "weight":counter[n]};
                if(isSelected(community) && isSelected(n)) {
                    console.log("PUSHING", link);
                    selectedLinks.push(link);
                }
            }*/
        }
    }

    function AddGroupsLinks() {
        updateLinks();  // filterNodes is called from inside updateLinks, Adding the superNode of the bundled nodes
        addLinks(groupOutLinks, true);
        addLinks(groupInLinks, false);
    }

    function toggleInfo(close=true){
        var MainInfo = document.getElementById("MainInfo");
        document.getElementById("distInfo").innerHTML='';
        MainInfo.innerHTML = '';
        MainInfo.style= "height: 100%;";

        var hoverInfo = document.createElement('div');
        hoverInfo.id = "hoverInfo";
        hoverInfo.style="float:right;";

        var b = document.createElement('button');
        b.className = "btn";
        b.style = "position: relative;\n" +
            "        z-index: 99;\n" +
            "        float: right;";
        b.onclick = toggleInfo;

        var i = document.createElement("i");
        i.className = "w3-xxxlarge fa fa-close";
        b.appendChild(i);
        console.log(b.innerHTML);
        {#<button class="btn" style="float: right" onclick="closeInfo()"><i class="w3-xxxlarge fa fa-close"></i></button>#}

        if (!close) {
            document.getElementById("MainInfo").appendChild(b);
            document.getElementById("MainInfo").append(hoverInfo);
        }

    }

    function groupOver(d) {
        toggleInfo(false);
        document.getElementById("distInfo").innerHTML = '';
        d3.selectAll(".focus").remove();
        const isGroup = groupMap === undefined ? false : groupMap[d.id] !== undefined;
        var p;
        var intMetrics = ["SCC", "community", "id"];
        for (var metric in d) {
            var metricName;
            if (overhead.indexOf(metric) < 0) {
                p = document.createElement("p");
                p.className = "hoverP";

                var val = isNaN(d[metric]) ? d[metric] :
                    (metric.includes("degree") || metric.includes("count")) || metric.includes("size") || intMetrics.includes(metric) ?
                        parseInt(d[metric]) : parseFloat(d[metric]).toFixed(8);
                if (metric.includes("names") || metric.includes('dist')) {
                    var p2 = document.createElement("p");
                    metricName = metric.includes("names") ? metric.slice(0, -1) : metric.slice(0, -5);
                    metricName = "Largest " + metricName;
                    p2.textContent = metric + ": " + val;
                    document.getElementById("distInfo").appendChild(p2);
                    val = val.split(',')[0];
                    p.textContent = metricName + ": " + val;
                }
                else {

                    const numericMetricName = (["name", "size", "id", groupType].includes(metric)) ? metric :
                        isGroup ? "avg_" + metric : metric;
                    p.textContent = numericMetricName + ": " + val;
                }
                document.getElementById("hoverInfo").appendChild(p);
            }
        }

    }

    function bundleNodes(d, i) {
        /*
            Bundling steps:
            - Get the corresponding superNode (i.e. the node representing the (community or SCC) of that group)
            - Switch the collapse state of that group to false
            - Remove the info box of the superNode which was activated by mouseover event
            - Get links between the superNode and other nodes in the network
            - Remove all nodes in bundled groups
            - Update network links to remove links between bundled sub-nodes and other nodes in the network
            - Add the bundled superNode to selectedNodes
            - Add links between the superNode and other nodes in the network
            - Filter the bidirectional links according to its checkbox
            - Filter edgeless nodes
            - Draw the network without the polygon of the clicked group
            * */
        // Creating the superNode


        collapseMap[d] = collapseMap[d] ? false : true;  // toggle it

        if (!collapseMap[d])  // currently not bundled, bundle it
            d3.selectAll(".focus").remove();


        AddGroupsLinks();  // updating links and adding superNode are inside this function
        filterBidirEdges();
        filterEdgelessNodes();

        //console.log(groupOutLinks);
        drawNetwork();


    }


</script>


</body>
