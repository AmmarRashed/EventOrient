<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

    <style>
    body {font-family: 'Times', cursive;}
    path {
        fill-opacity: .1;
        stroke-opacity: 1;
    }

</style>
<div class="ui-widget">
    <input id="search" size='54'>
    <button type="button" onclick="searchNode()">Find Node</button>
    <button type="button" onclick="resetNodes()">Reset</button>
    <br>

    <form name="myForm" method="POST">
        {% csrf_token %}
        <p id="textDate">Date: {{current_date}}</p>
        <input type="range" id="date_scroller" name="date" min="0" max="{{dates|length|add:"-1"}}" step="1" value="{{date_index}}"
                        style="width: 400px"
                onchange="updateDateText(this.value)">
        <br>
        Recalculate node metrics:
        <input type="checkbox" id="recalculate_metrics" name="recalculate_metrics">
        <br>
        Recalculate communities:
        <input type="checkbox" id="recalculate_coms_checked" name="recalculate_coms_checked">
        <br>
        Recalculate SCCs:
        <input type="checkbox" id="recalculate_SCCs_checked" name="recalculate_SCCs_checked">
        <br>
        Include community accounts (e.g. clubs):
        <input type="checkbox" id="include_foci" name="include_foci">
        <br>
        Friendship network (bidirectional edges only):
        <input type="checkbox" id="bidir" name="bidir"> There are {{ bidir_edges }} ({{ bidir_ratio }} %) bidirectional connections out of {{ edges_number }}
        <br>
        <br>
        degree: <input type="text" id="textInputDegree" value="{{degree_threshold}}" style="width: 50px"
                       name="degree_scroller"
                        onchange="updateScroll(this.value, 'degree')">{{avg_degree}}<br>

        0<input id="degree"
                type="range" value="{{degree_threshold}}" min="0" max="100" step="1"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputDegree')">100
        <br>

        betweenness: <input type="text" id="textInputBtw" value="{{btw_threshold}}" style="width: 50px"
                            name="btw_scroller"
                        onchange="updateScroll(this.value, 'betweenness')">{{avg_betweenness}}<br>

        0.0<input id="betweenness"
                type="range" value="{{btw_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputBtw')">1.0
        <br>
        pagerank: <input type="text" id="textInputPagerank" value="{{pagerank_threshold}}" style="width: 50px"
                         name="pagerank_scroller"
                        onchange="updateScroll(this.value, 'pagerank')">{{avg_pagerank}}<br>

        0.0<input id="pagerank"
                type="range" value="{{pagerank_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputPagerank')">1.0
        <br>
        closeness: <input type="text" id="textInputCloseness" value="{{closeness_threshold}}" style="width: 50px"
                          name="closeness_scroller"
                        onchange="updateScroll(this.value, 'closeness')">{{avg_closeness_centrality}}<br>

        0.0<input id="closeness"
                type="range" value="{{closeness_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputCloseness')">1.0
        <br>

        eigenvector: <input type="text" id="textInputEigenvector" value="{{eigenvector_threshold}}" style="width: 50px"
                            name="eigenvector_scroller"
                        onchange="updateScroll(this.value, 'eigenvector')">{{avg_eigenvector_centrality}}<br>

        0.0<input id="eigenvector"
                type="range" value="{{eigenvector_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputEigenvector')">1.0

        <br>
        Clustering Coefficient: <input type="text" id="textInputClustCoeff" value="{{clust_threshold}}" style="width: 50px"
                            name="clust_scroller"
                        onchange="updateScroll(this.value, 'clust')">{{avg_clustering_coefficient}}<br>

        0.0<input id="clust"
                type="range" value="{{clust_threshold}}" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'textInputClustCoeff')">1.0

        <br>
        Homophily: {{ homophily_value }} ( Heterogeneity: {{ heterogeneity }}, Threshold: {{ heterogeneity_threshold }})
        <br>
        Transitivity: {{ transitivity_value }}
        <br>
        Nodes size by:
        <select id="sizeBy" onchange="updateSize()">

        {% for metric in size_metrics %}
            <option value="{{ metric }}">{{ metric }}</option>
        {% endfor %}
        </select>
        <br>
        <input type="submit" value="filter">
    </form>
</div>

<div id="groupSettings">
    <p>Group by: <span id='groupLabel'>None</span></p>
</div>

{#<div id="curveSettings">#}
{#    <p>Type of curve: <span id='curveLabel'>curveBasisClosed</span></p>#}
{#</div>#}

<div id="scaleFactorSettings">
    <p>Scale of the groups: <span id='scaleFactorLabel'>1.2</span></p>
    <input type="range" min="1" max="3" value="1.2" step=".1" style="width: 400px"
           oninput="scaleFactor = value; d3.select('#scaleFactorLabel').text(scaleFactor); updateGroups()">

    <p>Network's gravity: <span id='gravityForce'>-600</span></p>
    <input type="range" min="-1200" max="200" value="-600" step="10" style="width: 400px"
           oninput="gravityForce = value; d3.select('#gravityForce').text(gravityForce); updateForce()">

</div>


<svg width="960" height="600"></svg>
<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">

<body>

<script>
    if ({{is_filtering}}){
        alert("Found {{nodes_number}} nodes\n\t{{edges_number}} edges");
    }
    document.getElementById("recalculate_metrics").checked = {{recalculate_checked}};
    document.getElementById("recalculate_coms_checked").checked = {{recalculate_coms_checked}};
    document.getElementById("recalculate_SCCs_checked").checked = {{recalculate_SCCs_checked}};
    document.getElementById("include_foci").checked = {{foci_checked}};
    document.getElementById("bidir").checked = {{bidir}};

    d3.select("svg").attr("width", window.screen.width)
        .attr("height", window.screen.height-150);

    // d3.select("svg").attr("width", 960)
    //     .attr("height", 500);

    const overhead = ["index","x","y","vy","vx"];

    var svg2 = d3.select("svg"),
        width = +svg2.attr("width"),
        height = +svg2.attr("height"),
        transform = d3.zoomIdentity;

    var svg = svg2.append("g");

    var zoom = d3.zoom()
        .scaleExtent([1 / 16, 8])
        .on("zoom", zoomed);

    svg2.call(zoom);

    zoom.scaleTo(svg2, 1/4);
    function zoomed() {
        svg.attr("transform", d3.event.transform);
    }
    svg.append('defs').append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':10,
            'markerHeight':10,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');


    var node,
        selectedDegree,
        is_directed,
        valueline = d3.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .curve(d3.curveCatmullRomClosed),
        paths,
        groups,
        groupIds,
        scaleFactor = 1.2,
        gravityForce = -600,
        polygon,
        centroid,
        graph,
        color,
        size_metric, avgSize, maxSize, minSize,
        groupTypes = ["None","SCC", "community"],
        groupType = "None",
        simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) {return d.id;}))
        .force("charge", d3.forceManyBody().strength(gravityForce))
        .force("center", d3.forceCenter(width/2, height/2));


    is_directed = true;  // TODO set checkbox for that

    {#var curveTypes = ['curveBasisClosed', 'curveCardinalClosed', 'curveCatmullRomClosed', 'curveLinearClosed'],#}

    {#selectedDegree = document.getElementById('degree').value;#}

    {#drawNetwork(selectedDegree, is_directed);#}
    drawNetwork();



    function drawNetwork(){
        d3.json("{% url 'Twitter:load_twitter_connections_json' %}", function(error, g) {
            if (error) throw error;

            graph = g;


            var select_group = d3.select('#groupSettings')
            .append('select')
            .attr('class','select_group')
            .on('change', function() {
                var val = d3.select('.select_group').property('value');
                d3.select('#groupLabel').text(val);
                groupType = val;
                {#valueline.curve(d3[val]);#}
                updateGroupIds();
                updateGroups();
            });

            var options_group = select_group
                .selectAll('option')
                .data(groupTypes).enter()
                .append('option')
                .text(function (d) { return d; });


            // create groups, links and nodes
            groups = svg.append('g').attr('class', 'groups');

            var colors = [];
            var i;
            for (i = 0; i < graph.nodes.length; i++) {
                colors.push(getRandomColor());
            }
            color = d3.scaleOrdinal(colors);

            graph.links.forEach(function (d) {
                d.source = d.source;
                d.target = d.target;
            });

            var link = svg.append("g")
                .style("stroke", "#aaa")
                .style("stroke-opacity", "0.8")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                .attr('marker-end', 'url(#arrowhead)');


            node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(graph.nodes)
                .enter().append("circle")
                // ;
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            //
            var label = svg.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(graph.nodes)
                .enter().append("text")
                .attr("class", "label");
            // .text(function(d){return d.id;});

            updateSize();

            svg.selectAll("circle")
                .on("mouseover", function (d) {

                    d3.select(this).style("r", node_over);

                    const focus = svg.append('g')
                        .attr('class', 'focus');
                    const cx = d3.select(this).attr("cx");
                    const cy = d3.select(this).attr("cy");

                    focus.append('rect')
                        .attr('height', 300 * 4)
                        .attr('width', 300 * 4)
                        .attr("x", cx)
                        .attr("y", cy);
                    var x = 0.0;
                    for (var metric in d) {
                        x += 1.2;
                        if (overhead.indexOf(metric) < 0) {
                            focus.append('text')
                                .attr('x', cx + 10)
                                .attr('y', cy + 10)
                                .attr('dy', x + 'em')
                                .attr('dx', '.5em')
                                .style("font-size", 50)
                                .text(metric + ": " + d[metric]);
                        }
                    }

                    d3.select('.overlay')
                        .styles({
                            fill: 'none',
                            'pointer-events': 'all'
                        });

                    d3.selectAll('.focus')
                        .style('opacity', 0.9);

                    d3.selectAll('.focus rect')
                        .styles({
                            fill: '#CFEEF1',
                            stroke: 'black'
                        });
                })
                .on("mouseout", function (d) {
                    d3.select(this).style("r", node_scale).style("fill-opacity", 0.7);
                    d3.selectAll(".focus").remove();
                });


            simulation
                .nodes(graph.nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(graph.links);

            function ticked() {
                link
                    .attr('x1', d => d.source.x )
                    .attr('y1', d => d.source.y )
                    .attr('x2', d => d.target.x )
                    .attr('y2', d => d.target.y );

                node
                    .attr("r", node_scale)
                    .attr('cx', d => d.x )
                    .attr('cy', d => d.y )
                    .style('fill-opacity', 0.7)
                    .style('fill', d => color(d.community))
                    .style('stroke', "none");

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .style("font-size", "10px")
                    .style("fill", "#4393c3")
                    .text(d => d.screen_name);


                {#updateGroups();#}

            }

        });

    }
        // .domain([{{minSize}},{{maxSize}}])
        // .range([1, 50]);
    function node_scale(d){
                return Math.max((Math.abs(d[size_metric]- avgSize))/(maxSize-minSize)*100, 5);
            }
    function node_over(d){

        return Math.max((Math.abs(d[size_metric] - avgSize))/(maxSize-minSize)* 180, 200);

    }

    function dragstarted(d){
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d){
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d){
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }


    // drag groups
    function group_dragstarted(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 3);
    }

    function group_dragged(groupId) {
        node
            .filter(function(d) { return d[groupType] == groupId; })
            {#.filter(function(d) { return d['SCC'] == groupId; })#}
            .each(function(d) {
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            })
    }

    function group_dragended(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 1);
    }


    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    function searchNode() {
        var selectedVal = document.getElementById('search').value;
        if (selectedVal == 'none') {}
        else {
            var selected = node.filter(function (d, i) {
                return (d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });

            var nonselected = node.filter(function (d, i) {
                return !(d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });
            nonselected.style("opacity", "0.1");
            selected.style("opacity", 1.0);
            selected.style("r",node_over);
            alert("Found: "+selected.size().toString());
            centerNode(selected.attr("cx"), selected.attr("cy"));

            // var link = svg.selectAll(".link");
            // link.style("opacity", "0");
            d3.selectAll(".node, .link").transition()
                .duration(3000)
                .style("opacity", '1');
        }

    }
    function resetNodes(){
        var all_nodes = node.filter(function (d, i){
            return true;
        });
        all_nodes.style("r", node_scale)
            .style("opacity",0.7);
    }
    function updateText(selectedDegree, widget){
        document.getElementById(widget).value=selectedDegree;
    }
    function updateScroll(selectedDegree, widget){
        document.getElementById(widget).value=selectedDegree;
    }

    function centerNode(xx, yy){
        svg.transition()
        .duration(500)
        .attr("transform", "translate(" + (width/2 - xx) + "," + (height/2 - yy) + ")scale(" + 1 + ")")
        .on("end", function(){ svg2.call(zoom.transform, d3.zoomIdentity.translate((width/2 - xx),(height/2 - yy)).scale(1))});
        }

    function updateDateText(date_index){
        var dates = {{dates_dumped|safe}};
        document.getElementById("textDate").innerHTML = "Date: "+dates[date_index].toString();
    }


    // select nodes of the group, retrieve its positions
    // and return the convex hull of the specified points
    // (3 points as minimum, otherwise returns null)
    var polygonGenerator = function(groupId) {
        var node_coords = node
            .filter(function(d) { return d[groupType] == groupId; })
            .data()
            .map(function(d) { return [d.x, d.y]; });

        return d3.polygonHull(node_coords);
    };


    function updateForce(){
        simulation.force("charge", d3.forceManyBody().strength(gravityForce));
        simulation.restart();
    }

    function updateSize(){
                size_metric = document.getElementById("sizeBy").value;
                avgSize = 0;
                maxSize = 0;
                minSize = Infinity;

                graph.nodes.forEach(function (d) {
                    avgSize += d[size_metric];
                    maxSize = Math.max(maxSize, d[size_metric]);
                    minSize = Math.min(maxSize, d[size_metric]);
                });
                avgSize /= graph.nodes.length;

                resetNodes();
            }

    function updateGroups() {
        groupIds.forEach(function(groupId) {
            var path = paths.filter(function(d) { return d == groupId;})
                .attr('transform', 'scale(1) translate(0,0)')
                .attr('d', function(d) {
                    polygon = polygonGenerator(d);
                    centroid = d3.polygonCentroid(polygon);

                    // to scale the shape properly around its points:
                    // move the 'g' element to the centroid point, translate
                    // all the path around the center of the 'g' and then
                    // we can scale the 'g' element properly
                    return valueline(
                        polygon.map(function(point) {
                            return [  point[0] - centroid[0], point[1] - centroid[1] ];
                        })
                    );
                });

            d3.select(path.node().parentNode).attr('transform', 'translate('  + centroid[0] + ',' + (centroid[1]) + ') scale(' + scaleFactor + ')');
        });
    }


    function updateGroupIds(){
            // count members of each group. Groups with less
            // than 3 member will not be considered (creating
            // a convex hull need 3 points at least)

            groups.selectAll('.path_placeholder').remove();

            groupIds = d3.set(graph.nodes.map(function(n) { return +n[groupType]; }))
                .values()
                .map( function(groupId) {
                    return {
                        groupId : groupId,
                        count : graph.nodes.filter(function(n) { return +n[groupType]  == groupId; }).length

                    };
                })
                .filter( function(group) { return group.count > 2;})
                .map( function(group) { return group.groupId; });

            paths = groups.selectAll('.path_placeholder')
                .data(groupIds, function(d) { return +d; })
                .enter()
                .append('g')
                .attr('class', 'path_placeholder')
                .append('path')
                .attr('stroke', function(d) { return color(d); })
                .attr('fill', function(d) { return color(d); })
                .attr('opacity', 0);

            paths
                .transition()
                .duration(1000)
                .attr('opacity', 1);

            // add interaction to the groups
            groups.selectAll('.path_placeholder')
                .call(d3.drag()
                    .on('start', group_dragstarted)
                    .on('drag', group_dragged)
                    .on('end', group_dragended)
                )
                .on("click", function(){console.log(d3.select(this).data());})

            }


</script>



</body>
