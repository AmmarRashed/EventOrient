<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

    <style>
    body {font-family: 'Times', cursive;}
    path {
        fill-opacity: .2;
        stroke-opacity: 1;
        stroke-width: 2;
    }

</style>
<div class="ui-widget">
    <input id="search" size='54'>
    <button type="button" onclick="searchNode()">Find Node</button>
    <button type="button" onclick="resetNodes()">Reset</button>
    <br>

    <form name="myForm" method="POST">
        {% csrf_token %}

        <p id="textDate">Date: {{current_date}}</p>
        <input type="range" id="date_scroller" name="date" min="0" max="{{dates|length|add:"-1"}}" step="1" value="{{date_index}}"
                        style="width: 400px"
                onchange="updateDateText(this.value)">

        </br>
        Nodes: <span id="num_nodes">{{ nodes_number }}</span> </br> Edges: <span id="num_edges">{{ edges_number }}</span>
        <br>Communities: <span id="num_communities"></span></br>
        Homophily: {{ homophily_value }} ( Heterogeneity: {{ heterogeneity }}, Threshold: {{ heterogeneity_threshold }})
        <br>
        Transitivity: {{ transitivity_value }}
        <br>
        Recalculate node metrics:
        <input type="checkbox" id="recalculate_metrics" name="recalculate_metrics">
        <br>
        Recalculate communities:
        <input type="checkbox" id="recalculate_coms_checked" name="recalculate_coms_checked">
        <br>
        Recalculate SCCs:
        <input type="checkbox" id="recalculate_SCCs_checked" name="recalculate_SCCs_checked">
        <br>
        <input type="submit" value="Construct Network"></br>
        Include community accounts (e.g. clubs):
        <input type="checkbox" id="toggleFociCB" name="toggleFociCB" oninput="filterNodes(); filterEdges();">
        <br>
        Friendship network (bidirectional edges only):
        <input type="checkbox" id="toggleBidir" name="toggleBidir" oninput="filterEdges()"> There are {{ bidir_edges }} ({{ bidir_ratio }} %) bidirectional connections out of {{ edges_number }}
        <br>
        <br>
        degree: <input type="text" id="text_degree" value="0" style="width: 50px"
                       name="text_degree"
                        onchange="updateScroll(this.value, 'degree')">{{avg_degree}}<br>

        0<input id="degree"
                type="range" value="0" min="0" max="100" step="1"
                style="width: 400px"
                onchange="updateText(this.value, 'text_degree')">100
        <br>

        betweenness: <input type="text" id="text_betweenness" value="0" style="width: 50px"
                            name="text_betweenness"
                        onchange="updateScroll(this.value, 'betweenness')">{{avg_betweenness}}<br>

        0.0<input id="betweenness"
                type="range" value="0" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_betweenness')">1.0
        <br>
        pagerank: <input type="text" id="text_pagerank" value="0" style="width: 50px"
                         name="text_pagerank"
                        onchange="updateScroll(this.value, 'pagerank')">{{avg_pagerank}}<br>

        0.0<input id="pagerank"
                type="range" value="0" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_pagerank')">1.0
        <br>
        closeness: <input type="text" id="text_closeness_centrality" value="0" style="width: 50px"
                          name="text_closeness_centrality"
                        onchange="updateScroll(this.value, 'closeness_centrality')">{{avg_closeness_centrality}}<br>

        0.0<input id="closeness_centrality"
                type="range" value="0" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_closeness_centrality')">1.0
        <br>

        eigenvector: <input type="text" id="text_eigenvector_centrality" value="0" style="width: 50px"
                            name="text_eigenvector_centrality"
                        onchange="updateScroll(this.value, 'eigenvector_centrality')">{{avg_eigenvector_centrality}}<br>

        0.0<input id="eigenvector_centrality"
                type="range" value="0" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_eigenvector_centrality')">1.0

        <br>
        Clustering Coefficient: <input type="text" id="text_clustering_coefficient" value="0" style="width: 50px"
                            name="text_clustering_coefficient"
                        onchange="updateScroll(this.value, 'clustering_coefficient')">{{avg_clustering_coefficient}}<br>

        0.0<input id="clustering_coefficient"
                type="range" value="0" min="0.0" max="1.0" step="0.01"
                style="width: 400px"
                onchange="updateText(this.value, 'text_clustering_coefficient')">1.0

        <br>
        Nodes size by:
        <select id="sizeBy" onchange="updateSize()">

        {% for metric in size_metrics %}
            <option value="{{ metric }}">{{ metric }}</option>
        {% endfor %}
        </select>
        <br>
    </form>
    <input id="filter" type="submit" title="remove nodes with no connections" value="Clean Network" onclick="removeEdgeLessNodes();">
</div>

<div id="groupSettings">
    <p>Group by: <span id='groupLabel'>None</span></p>
</div>
</br>
<input id="bundleReset" type="submit" title="Ungroup all groups" value="Clear grouping" onclick="resetBundling();">
{#<div id="curveSettings">#}
{#    <p>Type of curve: <span id='curveLabel'>curveBasisClosed</span></p>#}
{#</div>#}

<div id="scaleFactorSettings">
    <p>Scale of the groups: <span id='scaleFactorLabel'>1.2</span></p>
    <input type="range" min="1" max="3" value="1.2" step=".1" style="width: 400px"
           oninput="scaleFactor = value; d3.select('#scaleFactorLabel').text(scaleFactor); updateGroups()">

    <p>Network's gravity: <span id='gravityForce'>-600</span></p>
    <input type="range" min="-5000" max="200" value="-600" step="10" style="width: 400px"
           oninput="gravityForce = value; d3.select('#gravityForce').text(gravityForce); updateForce()">

    <p>Nodes' sizes: <span id='nodeScaler'>100</span></p>
    <input type="range" min="1" max="500" value="100" step="10" style="width: 400px"
           oninput="sizeScaler= value; d3.select('#nodeScaler').text(sizeScaler); resetNodes()">

</div>


<svg width="960" height="600"></svg>
<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet">

<body>

<script>

    document.getElementById("recalculate_metrics").checked = {{recalculate_checked}};
    document.getElementById("recalculate_coms_checked").checked = {{recalculate_coms_checked}};
    document.getElementById("recalculate_SCCs_checked").checked = {{recalculate_SCCs_checked}};
    document.getElementById("toggleFociCB").checked = {{foci_checked}};

    document.getElementById("toggleBidir").checked = {{bidir}};

    d3.select("svg").attr("width", window.screen.width)
        .attr("height", window.screen.height-150);

    // d3.select("svg").attr("width", 960)
    //     .attr("height", 500);

    const overhead = ["index","x","y","vy","vx"];

    var svg2 = d3.select("svg"),
        width = +svg2.attr("width"),
        height = +svg2.attr("height"),
        transform = d3.zoomIdentity;

    var svg = svg2.append("g");

    var zoom = d3.zoom()
        .scaleExtent([1 / 16, 8])
        .on("zoom", zoomed);

    svg2.call(zoom);

    zoom.scaleTo(svg2, 1/4);
    function zoomed() {
        svg.attr("transform", d3.event.transform);
    }
    svg.append('defs').append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':10,
            'markerHeight':10,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');


    var node,
        is_directed,
        communitiesSet,
        valueline = d3.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .curve(d3.curveCatmullRomClosed),
        toggleFociChecked,
        nodesIndices,
        toggleBidir,
        selectedNodes,
        selectedLinks,
        paths,
        groups,
        groupIds,
        scaleFactor = 1.2,
        gravityForce = -600,
        sizeScaler=100,
        polygon,
        centroid,
        graph,
        color,
        size_metric, avgSize, maxSize, minSize,
        groupTypes = ["None","SCC", "community"],
        groupType = "None",
        simulation= d3.forceSimulation()
                            .force("link", d3.forceLink().id(function (d) {return d.id;})).strength(gravityForce)
                            .force("charge", d3.forceManyBody().strength(gravityForce))
                            .force("center", d3.forceCenter(width/2, height/2));


    is_directed = true;  // TODO set checkbox for that

    {#var curveTypes = ['curveBasisClosed', 'curveCardinalClosed', 'curveCatmullRomClosed', 'curveLinearClosed'],#}

    {#selectedDegree = document.getElementById('degree').value;#}

    {#drawNetwork(selectedDegree, is_directed);#}
    drawNetwork();

    function drawNetwork(){
        d3.json("{% url 'Twitter:load_twitter_connections_json' %}", function(error, g) {
            if (error) throw error;

            graph = g;

            d3.selectAll('.select_group').remove();
            svg.selectAll('*').remove();

            if (typeof selectedNodes == 'undefined') {  // first run
                selectedNodes = graph.nodes;
                filterNodes();
                updateGraphLinks();
                updateLinks();
                drawNetwork();
            }

            updateStatus();

            d3.select('#groupSettings')
            .append('select')
            .attr('class','select_group')
            .on('change', function() {
                var val = d3.select('.select_group').property('value');
                d3.select('#groupLabel').text(val);
                groupType = val;
                {#valueline.curve(d3[val]);#}
                updateGroupIds();
                updateGroups();
            })
            .selectAll('option')
                .data(groupTypes).enter()
                .append('option')
                .text(function (d) { return d; });


            // create groups, links and nodes
            groups = svg.append('g').attr('class', 'groups');

            /*var colors = [];

            communitiesSet.forEach(function (c){
               colors.push(getRandomColor());
            });

            color = d3.scaleOrdinal(colors);
            */

            color = d3.scaleOrdinal(d3.schemeCategory20);


            var link = svg.append("g")
                .style("stroke", "#aaa")
                .style("stroke-opacity", "0.8")
                .selectAll("line")
                .data(selectedLinks)
                .enter().append("line")
                .attr('marker-end', 'url(#arrowhead)');


            node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(selectedNodes)
                .enter().append("circle")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));


            var label = svg.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(selectedNodes)
                .enter().append("text")
                .attr("class", "label");
            // .text(function(d){return d.id;});

            updateSize();

            svg.selectAll("circle")
                .on("mouseover", function (d) {

                    d3.select(this).style("r", node_over);

                    const focus = svg.append('g')
                        .attr('class', 'focus');
                    const cx = d3.select(this).attr("cx");
                    const cy = d3.select(this).attr("cy");

                    focus.append('rect')
                        .attr('height', 300 * 4)
                        .attr('width', 300 * 4)
                        .attr("x", cx)
                        .attr("y", cy);
                    var x = 0.0;
                    for (var metric in d) {
                        x += 1.2;
                        if (overhead.indexOf(metric) < 0) {
                            focus.append('text')
                                .attr('x', cx + 10)
                                .attr('y', cy + 10)
                                .attr('dy', x + 'em')
                                .attr('dx', '.5em')
                                .style("font-size", 50)
                                .text(metric + ": " + d[metric]);
                        }
                    }

                    d3.select('.overlay')
                        .styles({
                            fill: 'none',
                            'pointer-events': 'all'
                        });

                    d3.selectAll('.focus')
                        .style('opacity', 0.9);

                    d3.selectAll('.focus rect')
                        .styles({
                            fill: '#CFEEF1',
                            stroke: 'black'
                        });
                })
                .on("mouseout", function (d) {
                    d3.select(this).style("r", node_scale).style("fill-opacity", 0.7);
                    d3.selectAll(".focus").remove();
                });


            simulation
                .nodes(selectedNodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(selectedLinks);

            function ticked() {
                link
                    .attr('x1', d => d.source.x )
                    .attr('y1', d => d.source.y )
                    .attr('x2', d => d.target.x )
                    .attr('y2', d => d.target.y );

                node
                    .attr("r", node_scale)
                    .attr('cx', d => d.x )
                    .attr('cy', d => d.y )
                    .style('fill-opacity', 0.7)
                    .style('fill', d => color(d.community))
                    .style('stroke', "none");

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .style("font-size", "10px")
                    .style("fill", "#4393c3")
                    .text(d => d.screen_name);


                updateGroups();

            }

        });

    }
        // .domain([{{minSize}},{{maxSize}}])
        // .range([1, 50]);

        function node_scale(d){

                return Math.max((Math.abs(d[size_metric]- avgSize))/(maxSize-minSize)*sizeScaler, sizeScaler/20);
            }
    function node_over(d){

        return Math.max((Math.abs(d[size_metric] - avgSize))/(maxSize-minSize)* (sizeScaler*1.8), sizeScaler*2);

    }

    function dragstarted(d){
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d){
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d){
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }


    // drag groups
    function group_dragstarted(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 3);
    }

    function group_dragged(groupId) {
        node
            .filter(function(d) { return d[groupType] == groupId; })
            {#.filter(function(d) { return d['SCC'] == groupId; })#}
            .each(function(d) {
                d.x += d3.event.dx;
                d.y += d3.event.dy;
            })
    }

    function group_dragended(groupId) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d3.select(this).select('path').style('stroke-width', 1);
    }


    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    function searchNode() {
        var selectedVal = document.getElementById('search').value;
        if (selectedVal == 'none') {}
        else {
            var selected = node.filter(function (d, i) {
                return (d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });

            var nonselected = node.filter(function (d, i) {
                return !(d.screen_name.includes(selectedVal) ||
                    d.match_name.includes(selectedVal) ||
                    d.name.includes(selectedVal));
            });
            nonselected.style("opacity", "0.1");
            selected.style("opacity", 1.0);
            selected.style("r",node_over);
            alert("Found: "+selected.size().toString());
            centerNode(selected.attr("cx"), selected.attr("cy"));

            // var link = svg.selectAll(".link");
            // link.style("opacity", "0");
            d3.selectAll(".node, .link").transition()
                .duration(3000)
                .style("opacity", '1');
        }

    }

    function resetBundling(){
            filterNodes();
            updateGraphLinks();
            updateLinks();
            drawNetwork();
    }

    function resetNodes(){
        var all_nodes = node.filter(function (d, i){
            return true;
        });
        all_nodes.style("r", node_scale)
            .style("opacity",0.7);
    }
    function updateText(threshold, widget){
        {#var metric = widget.slice(5);  // text_degree => degree  (removing 'text_')#}

        document.getElementById(widget).value=threshold;
        filterNodes();
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }
    function updateScroll(threshold, widget){

        document.getElementById(widget).value=threshold;
        filterNodes();
        updateGraphLinks();
        updateLinks();
        drawNetwork();
    }

    function centerNode(xx, yy){
        svg.transition()
        .duration(500)
        .attr("transform", "translate(" + (width/2 - xx) + "," + (height/2 - yy) + ")scale(" + 1 + ")")
        .on("end", function(){ svg2.call(zoom.transform, d3.zoomIdentity.translate((width/2 - xx),(height/2 - yy)).scale(1))});
        }

    function updateDateText(date_index){
        var dates = {{dates_dumped|safe}};
        document.getElementById("textDate").innerHTML = "Date: "+dates[date_index].toString();
    }


    // select nodes of the group, retrieve its positions
    // and return the convex hull of the specified points
    // (3 points as minimum, otherwise returns null)
    var polygonGenerator = function(groupId) {
        var node_coords = node
            .filter(function(d) { return d[groupType] == groupId; })
            .data()
            .map(function(d) { return [d.x, d.y]; });

        return d3.polygonHull(node_coords);
    };


    function updateForce(){
        simulation.force("link", d3.forceLink().id(function (d) {return d.id;})).distance(-1*gravityForce);

    }

    function updateSize(){
                size_metric = document.getElementById("sizeBy").value;
                avgSize = 0;
                maxSize = Number.NEGATIVE_INFINITY;
                minSize = Number.POSITIVE_INFINITY;

                selectedNodes.forEach(function (d) {
                    avgSize += d[size_metric];
                    maxSize = Math.max(maxSize, d[size_metric]);
                    minSize = Math.min(maxSize, d[size_metric]);
                });
                avgSize /= selectedNodes.length;

                resetNodes();
            }

    function updateGroups() {
        if (!((typeof groupIds == 'undefined') || (groupIds == null))) {
            try {
                groupIds.forEach(function (groupId) {
                    var path = paths.filter(function (d) {
                        return d == groupId;
                    })
                        .attr('transform', 'scale(1) translate(0,0)')
                        .attr('d', function (d) {
                            polygon = polygonGenerator(d);

                            centroid = d3.polygonCentroid(polygon);

                            // to scale the shape properly around its points:
                            // move the 'g' element to the centroid point, translate
                            // all the path around the center of the 'g' and then
                            // we can scale the 'g' element properly
                            return valueline(
                                polygon.map(function (point) {
                                    return [point[0] - centroid[0], point[1] - centroid[1]];
                                })
                            );
                        });

                    d3.select(path.node().parentNode).attr('transform', 'translate(' + centroid[0] + ',' + (centroid[1]) + ') scale(' + scaleFactor + ')');
                });
            }catch (err){
                console.log("ERROR:", err)
            }
        }
    }

    function countCommunities() {
        communitiesSet = new Set([]);
        selectedNodes.forEach(function (node){
            communitiesSet.add(parseInt(node.community));
        });
        return communitiesSet.size;

    }

    function getLinkEnd(n){
        if (typeof n == 'number')
            return n;
        else
            return parseInt(n.id);
    }


    function updateLinks(){

        selectedLinks = selectedLinks.filter(function(l){
            var valid=0;

            for (var n in selectedNodes){
                node_id   = getLinkEnd(selectedNodes[n]);
                source_id = getLinkEnd(l.source);
                target_id = getLinkEnd(l.target);


                {#console.log(node_id, source_id, l.source);#}

                if (node_id === source_id)
                    valid += 1;
                if (node_id === target_id)
                    valid += 1;
                if (valid>1)
                    return true;
            }
            return false;
            {#return selectedNodes.includes(link.source) && selectedNodes.includes(link.target);#}
        });

        updateStatus();
    }

    function updateGraphLinks(){

        graph.links.forEach(function (d) {
            d.source = d.source;
            d.target = d.target;
        });

        selectedLinks = graph.links;
    }

    function filterEdges(){
        toggleBidir = document.getElementById("toggleBidir").checked;
        if (toggleBidir) {
            selectedLinks = graph.links.filter(function (l1) {
                for (var l2_ in selectedLinks){
                    var l2 = selectedLinks[l2_];
                    {#console.log(l1.source, l2.source);#}
                    if ((l1.source == l2.target.id) && (l2.source.id == l1.target))
                        return true;
                }
                return false;
            });
        }
        else {
            selectedLinks = graph.links;
            filterNodes();
        }
        updateLinks();
        drawNetwork();
    }


    function updateStatus(){
        var comCount = countCommunities();

        d3.select("#num_nodes").text(selectedNodes.length.toString());
        d3.select("#num_edges").text(selectedLinks.length.toString());
        d3.select("#num_communities").text(comCount.toString());
    }

    function removeEdgeLessNodes(){
        selectedNodes = selectedNodes.filter(function (n){
            for (var l_ in selectedLinks){
                var l = selectedLinks[l_];
                if ((l.source == n) || (l.target==n))
                    return true;
            }
            return false;
        });


        drawNetwork();
    }


    function filterNodes() {
        var metrics = ["degree", "betweenness", "pagerank", "community",
                "closeness_centrality", "eigenvector_centrality", 'clustering_coefficient'];

        toggleFociChecked = document.getElementById("toggleFociCB").checked;
        // replace community label 'foci' by '0'
        graph.nodes.forEach(function(node){
            if (node.community.toString().toLowerCase().includes('foci'))
                node.community = 0;
            else {
                node.community = parseInt(node.community);
            }
        });

        nodesIndices = {'__':0};

        selectedNodes =
            graph.nodes.filter(function(node){
                for (var metric in node) {
                    if (metrics.includes(metric)) {
                        if (metric.includes("community")) {
                            if (!(toggleFociChecked || !(node.screen_name.toString().toLowerCase().includes('sehir'))))
                                return false;
                        }
                        else {
                            var metricThreshold = parseFloat(document.getElementById(metric).value);
                            if (node[metric] < metricThreshold)
                                return false;
                        }
                    }
                }
                return true;
            });
        for (var n in selectedNodes){
            nodesIndices[selectedNodes[n].id] = n;
        }
        delete nodesIndices.__

    }


    function updateGroupIds(){
        // count members of each group. Groups with less
        // than 3 member will not be considered (creating
        // a convex hull need 3 points at least)

        groups.selectAll('.path_placeholder').remove();

        groupIds = d3.set(selectedNodes.map(function(n) { return +n[groupType]; }))
            .values()
            .map( function(groupId) {
                return {
                    groupId : groupId,
                    count : selectedNodes.filter(function(n) { return +n[groupType]  == groupId; }).length

                };
            })
            .filter( function(group) { return group.count > 2;})
            .map( function(group) { return group.groupId; });

        paths = groups.selectAll('.path_placeholder')
            .data(groupIds, function(d) { return +d; })
            .enter()
            .append('g')
            .attr('class', 'path_placeholder')
            .append('path')
            .attr('stroke', function(d) { return color(d); })
            .attr('fill', function(d) { return color(d); })
            .attr('opacity', 0);

        paths
            .transition()
            .duration(1000)
            .attr('opacity', 1);

        // add interaction to the groups
        groups.selectAll('.path_placeholder')
            .call(d3.drag()
                .on('start', group_dragstarted)
                .on('drag', group_dragged)
                .on('end', group_dragended)
            )
            .on("click", bundleNodes)

        }

        function bundleNodes() {
        // Creating the superNode
            var clickedGroupId = d3.select(this).data()[0];
            var groupNodes = selectedNodes.filter(function(n){
                return n[groupType] == clickedGroupId;
            });

            var superNode = {'i':0};
            var counter = {'i':0};
            console.log("From: ", selectedNodes.length);
            groupNodes.forEach(function (node){
                // remove those nodes from selectedNodes
                var index = selectedNodes.indexOf(node);
                if (index > -1) {
                    selectedNodes.splice(index, 1);
                }
                for (var metric in node){
                    if (!(superNode.hasOwnProperty(metric))) {
                        if (typeof metric == 'number')
                            superNode[metric] = 0;
                        else {
                            var metricVal = node[metric].toString();
                            counter[metric] = {'i':0};
                            counter[metric][metricVal] = 0;
                        }
                    }

                    if (typeof metric == 'number')
                        superNode[metric] += node[metric].val;
                    else
                        counter[metric][node[metric]] += 1;
                }
            });
            for (var m in superNode){
                superNode[m] /= groupNodes.length;
            }
            for (var metric in counter){
                var maxFreq = Number.NEGATIVE_INFINITY;
                var maxVal;
                for (var counterVal in counter[metric]){
                    var freq = counter[metric][counterVal];

                    if (freq>maxFreq){
                        maxFreq = freq;
                        maxVal = counterVal;
                    }
                }

                superNode[metric] = maxVal;

            }
            delete superNode.i;
            superNode.id = parseInt(superNode[groupType]);
            superNode.screen_name = groupType+"_"+superNode[groupType];
            superNode.size = groupNodes.length;

            // Remove the group from groups and groupsIds
            var index = groupIds.indexOf(clickedGroupId);
            if (index>-1){
                groupIds.splice(index, 1);
            }

            updateGroupIds();
            updateGroups();

            // Adding the superNode to the network nodes
            selectedNodes[selectedNodes.length] = superNode;

            console.log("to: ", selectedNodes.length);
            console.log("groupNode size: ", superNode.size);

            selectedLinks.forEach(function (l) {
                var source = selectedNodes[nodesIndices[getLinkEnd(l.source)]];
                var target = selectedNodes[nodesIndices[getLinkEnd(l.target)]];

                if (source[groupType] == superNode[groupType]) {
                    console.log(l.source, superNode.id);
                    l.source = superNode.id;
                }
                if (target[groupType] == superNode[groupType]) {
                    l.target = superNode.id;
                }
            });

            updateLinks();
            drawNetwork();

            

        }


</script>



</body>
